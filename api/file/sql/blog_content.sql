/*
 Navicat Premium Data Transfer

 Source Server         : 121.4.126.60
 Source Server Type    : MySQL
 Source Server Version : 50737
 Source Host           : 121.4.126.60:3306
 Source Schema         : blog_content

 Target Server Type    : MySQL
 Target Server Version : 50737
 File Encoding         : 65001

 Date: 28/05/2023 22:12:44
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(10) UNSIGNED NULL DEFAULT NULL COMMENT '文章发布用户',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `content_md` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'markdown格式文章内容',
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'html格式文章内容',
  `article_type` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章类型（分类由大到小使用 , 隔开）',
  `article_label` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标签（标签顺序不分先后 使用 , 隔开）',
  `article_status` tinyint(4) NULL DEFAULT NULL COMMENT '文章状态（2：置顶 1：发布 0：草稿）',
  `browse_count` int(11) NULL DEFAULT NULL COMMENT '文章浏览次数',
  `like_count` int(11) NULL DEFAULT NULL COMMENT '文章点赞次数',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '文章创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '文章最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 106 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (43, 1, '【洛谷】P1873-EKO  砍树-二分', '## 题目描述\n\n伐木工人 Mirko 需要砍 M 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。\n\nMirko 的伐木机工作流程如下：Mirko 设置一个高度参数 H（米），伐木机升起一个巨大的锯片到高度 H，并锯掉所有树比 H 高的部分（当然，树木不高于 H 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 20,15,10 和 17，Mirko 把锯片升到 15 米的高度，切割后树木剩下的高度将是 15,15,10 和 15，而 Mirko 将从第 1 棵树得到 5 米，从第 4 棵树得到 2 米，共得到 7 米木材。\n\nMirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 H，使得他能得到的木材至少为 M 米。换句话说，如果再升高 1 米，他将得不到 M 米木材。\n\n## 输入格式\n\n第 1 行 2 个整数 N 和 M，N 表示树木的数量，M 表示需要的木材总长度。\n\n第 2 行 N 个整数表示每棵树的高度。\n\n## 输出格式\n1 个整数，表示锯片的最高高度。\n\n## 输入输出样例\n### 输入\n```\n4 7\n20 15 10 17\n```\n### 输出\n```\n15\n```\n## 说明/提示\n对于 100% 的测试数据，1≤N≤10^6^, 1≤M≤2×10^9^，树的高度 <10^9^，所有树的高度总和 >M。\n## 解析\n这道题的标签是二分，不过我的解法没有使用二分，算是以数目高度排序之后的暴力枚举解法。\n由题意可知要求锯片高度尽可能高，所以应该从最高的树木开始，然后降低锯片高度直到找到刚好能够满足题目要求的木材数量然后输出答案，但是这个会有个问题，就是树木的最大高度是10^9^,依次降低高度必然超时，所以需要用到排序，当树木高度有序时每次将锯片的高度降为前一棵树的高度，此次下降锯片砍树总长度 = （前一棵树高度 - 当前树高度）*  被砍树木数， 总砍树长度 = 此次下降锯片砍树总长度 + 之前砍树的总长度，  直到总砍树长度比目标长度大时需要抬高锯片，抬高锯片的高度 = 多余的砍树高度 / 被砍树木数。\n\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint arr[1000000];\nint len,num;\n\nint main() {\n    cin>>n>>m;\n    for(int i=0; i<n; i++){\n        cin>>arr[i];\n    }\n    sort(arr,arr+n);\n    len = 0;\n    num = n-1;\n    while(len<m){\n        len += (arr[num]-arr[num-1]) * (n-num);\n        num--;\n    }\n    cout<<arr[num] + (len-m) / (n-num-1)<<endl;\n	return 0;\n}\n```\n', NULL, '1,2', '4', 1, 0, 0, '2023-01-23 10:30:35', '2023-01-23 10:49:04');
INSERT INTO `article` VALUES (44, 1, '【洛谷】P1443-马的遍历-bfs', '## 题目描述\n有一个 n×m 的棋盘，在某个点 (x,y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。\n\n## 输入格式\n输入只有一行四个整数，分别为 n,m,x,y。\n\n## 输出格式\n一个 n×m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 −1）。\n\n## 输入输出样例\n### 输入\n```\n3 3 1 1\n```\n### 输出\n```\n0    3    2    \n3    -1   1    \n2    1    4    \n```\n## 说明/提示\n对于全部的测试点，保证 1≤x≤n≤400，1≤y≤m≤400。\n\n## 解析\n裸bfs\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,x,y;\n// 记录马的移动位置\nint dx[8]={-1,1,-2,2,2,1,-1,-2};\nint dy[8]={2,2,1,1,-1,-2,-2,-1};\nint mapp[401][401];\nstruct node{\n    int x;\n    int y;\n    int k;\n};\n\nint bfs(){\n    queue<node> q;\n    struct node start;\n    start.x = x;\n    start.y = y;\n    start.k = 0;\n    q.push(start);\n    memset(mapp,-1,sizeof(mapp));\n    mapp[x][y]=0;\n    while(!q.empty()){\n        struct node p;\n        p=q.front();\n        q.pop();\n        for(int i=0; i<8; i++){\n            int nx = p.x+dx[i];\n            int ny = p.y+dy[i];\n            if(nx>=1 && ny>=1 && nx<=n && ny<=m){\n            	// -1 表示没到过该点\n                if(mapp[nx][ny]==-1){\n                    mapp[nx][ny]=p.k+1;\n                    struct node np;\n                    np.x = nx;\n                    np.y = ny;\n                    np.k = p.k+1;\n                    q.push(np);\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    cin>>n>>m;\n    cin>>x>>y;\n    bfs();\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n        	// 输出格式，五格范围\n            printf(\"%-5d\", mapp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n	return 0;\n}\n```\n', NULL, '1,2,4', '4', 1, 0, 0, '2023-01-23 10:47:15', '2023-01-23 10:47:45');
INSERT INTO `article` VALUES (45, 1, '【洛谷】P2036-PERKET-dfs', '\n## 题目描述\nPerket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 n 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 s 和苦度 b。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。\n\n众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。\n\n另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。\n\n## 输入格式\n\n第一行一个整数 n，表示可供选用的食材种类数。\n\n接下来 n 行，每行 2 个整数 si 和 bi，表示第 i 种食材的酸度和苦度。\n\n## 输出格式\n一行一个整数，表示可能的总酸度和总苦度的最小绝对差。\n\n## 输入输出样例\n### 输入\n```\n4\n1 7\n2 6\n3 8\n4 9\n```\n### 输出\n```\n1\n```\n## 说明/提示\n\n对于 100% 的数据，有 1≤n≤10，且将所有可用食材全部使用产生的总酸度和总苦度小于 1×10^9^，酸度和苦度不同时为 1 和 0。\n## 解析\n简单的dfs，暴搜就行，搜索之前先设置此次搜索要选择几个数据，可以简化逻辑\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint ans=1e9;\nint flag[10];\nstruct data{\n    int s;\n    int b;\n};\nstruct data arr[10];\n\n// select 当前选择了几个数据 selected 要选择几个数据\n// sSum 酸度乘积 bSum 苦度总和 \nvoid dfs(int select,int selected, int sSum, int bSum){\n    if(select == selected){\n        ans = min(abs(sSum-bSum), ans);\n    } else {\n        for(int i=0; i<n; i++){\n            if(!flag[i]){\n                flag[i]=1;\n                dfs(select+1, selected, sSum*arr[i].s, bSum+arr[i].b);\n                flag[i]=0;\n            }\n        }\n    }\n\n}\n\nint main() {\n\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d%d\", &arr[i].s, &arr[i].b);\n    }\n\n    for(int i=1; i<=n; i++){\n        dfs(0, i, 1, 0);\n    }\n\n    cout<<ans<<endl;\n	return 0;\n}\n```\n', NULL, '1,2,4', '4', 1, 0, 0, '2023-01-23 10:51:02', '2023-01-23 10:51:02');
INSERT INTO `article` VALUES (46, 1, '【洛谷】P2392-kkksc03考前临时抱佛脚-01背包', '## 题目描述\n\n\n这次期末考试，kkksc03 需要考 44 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1, s2, s3, s4 道题目，完成每道题目需要一些时间，可能不等（A1, A2,…,As1，B1,B2,…,Bs2，C1,C2 ,…,Cs3，D1,D2,…,Ds4）。\n\nkkksc03 有一个能力，他的左右两个大脑可以同时计算 2 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。\n\n由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。\n\n## 输入格式\n\n\n本题包含 55 行数据：第 11 行，为四个正整数 s1, s2, s3, s4 。\n\n第 2 行，为 A1,A2,…,As1 共 s1 个数，表示第一科习题集每道题目所消耗的时间。\n\n第 3 行，为 B1,B2,…,Bs2 共 s2 个数。\n\n第 4 行，为 C1,C2,…,Cs3 共 s3 个数。\n\n第 5 行，为 D1,D2,…,Ds4 共 s4 个数，意思均同上。\n\n## 输出格式\n输出一行,为复习完毕最短时间。\n\n## 输入输出样例\n### 输入\n```\n1 2 1 3		\n5\n4 3\n6\n2 4 3\n```\n### 输出\n```\n20\n```\n## 说明/提示\n1≤s1, s2, s3, s4 ≤20。\n\n1≤A1, A2,…,As1，B1,B2,…,Bs2，C1,C2 ,…,Cs3，D1,D2,…,Ds4≤60。\n## 解析\n看题目数据范围不是很大，暴搜应该也可以解决，不过我的解法是背包的思路。\n首先有四科习题，但是每次只能是对同一科的习题进行同时计算，所以只需要依次算出每科习题的最短时间求和就行，因为结果互不影响。单独算一组习题需要将这组习题分成俩个小组，并且这俩组的差值要最小，所以我选用的思路是设置一个背包，背包容量是所有习题时间的总和的一半，然后让这个背包尽可能的装满。\n\n\n\n```c++\n// 二维dp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint s[4];\nint arr[4][21];\nint dp[21][1201],sum;\n\nint backpack(int k){\n    int n = s[k];\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=sum; j++){\n            if(arr[k][i]>j){\n                dp[i][j] = dp[i-1][j];\n            } else {\n                dp[i][j] = max(dp[i-1][j-arr[k][i]] + arr[k][i], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[n][sum];\n}\n\nint main() {\n\n    for(int i=0; i<4; i++){\n        cin>>s[i];\n    }\n    int ans=0;\n    for(int i=0; i<4; i++){\n        int k = s[i];\n        sum=0;\n        int all;\n        for(int j=1; j<=k; j++){\n            cin>>arr[i][j];\n            sum+=arr[i][j];\n        }\n        all = sum;\n        sum/=2;\n        ans += all - backpack(i);\n    }\n    cout<<ans<<endl;\n	return 0;\n}\n\n// 一维dp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint s[4];\nint arr[4][21];\nint dp[1201],sum;\n\nint backpack(int k){\n    int n = s[k];\n    memset(dp, 0, sizeof(dp));\n    for(int i=1; i<=n; i++){\n        for(int j=sum; j>=0; j--){\n            int x = arr[k][i];\n            if(j>=x){\n                dp[j] = max(dp[j], dp[j-x]+x);\n            }\n        }\n    }\n    return dp[sum];\n}\n\nint main() {\n\n    for(int i=0; i<4; i++){\n        cin>>s[i];\n    }\n    int ans=0;\n    for(int i=0; i<4; i++){\n        int k = s[i];\n        sum=0;\n        int all;\n        for(int j=1; j<=k; j++){\n            cin>>arr[i][j];\n            sum+=arr[i][j];\n        }\n        all = sum;\n        sum/=2;\n        ans += all - backpack(i);\n    }\n    cout<<ans<<endl;\n	return 0;\n}\n```\n', NULL, '1,2', '', 1, 0, 0, '2023-01-23 10:52:15', '2023-01-23 10:52:15');
INSERT INTO `article` VALUES (47, 1, '【洛谷】P3817-小A的糖果-贪心', '## 题目描述\n\n小 A 有 n 个糖果盒，第 i 个盒中有 ai 颗糖果。\n小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 x，至少得吃掉几颗糖。\n\n## 输入格式\n\n输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 n 和给定的参数 x 。\n\n第二行有 n 个用空格隔开的整数，第 i 个整数代表第 i 盒糖的糖果个数 ai 。\n\n## 输出格式\n输出一行一个整数，代表最少要吃掉的糖果的数量。\n## 数据范围\n```\n对于 30% 的数据，保证 n≤20，ai, x ≤ 100\n对于 70% 的数据，保证 n≤10^3 ，ai, x ≤10^5 \n对于 100% 的数据，保证 2≤n≤10^5 , 0≤ai ,x≤10^9\n```\n\n## 输入输出样例\n### 输入\n```\n6 1\n1 6 1 2 0 4\n```\n### 输出\n```\n11\n```\n### 提示\n>第 2 盒糖吃掉 66 颗，第 4 盒吃掉 22 颗，第 6 盒吃掉 33 颗\n## 解析\n判断相邻俩盒糖果数量是否大于x，只需要从头开始遍历数组判断当前盒中糖果数量是否大于x和当前糖果盒和前一个糖果盒中糖果数量之和是否大于x（当前盒和下一盒可以等效替换），还有就是吃糖果要优先吃当前这盒中的，这样可以使下一盒结果最优。\n代码如下：\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define MAXN 100001\n\nint n,x;\nint arr[MAXN];\n// \nlong long ans=0;\n\nint main(){\n    scanf(\"%d%d\", &n,&x);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &arr[i]);\n    }\n    if(arr[0]>x){\n        ans = arr[0]-x;\n        arr[0] = x;\n    }\n    for(int i=1; i<n; i++){\n        if(arr[i]>x){\n            ans += arr[i]-x;\n            arr[i] = x;\n        }\n        if(arr[i]+arr[i-1]>x){\n            ans += arr[i]+arr[i-1]-x;\n            arr[i]=x-arr[i-1];\n        }\n    }\n\n    printf(\"%lld\", ans);\n    return 0;\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-01-25 10:54:31', '2023-01-25 10:54:46');
INSERT INTO `article` VALUES (48, 1, '【公司】约瑟夫环问题-递归解法', '## 题目描述\n公司绝对按照最近很火的《鱿鱼游戏》一样，再年会上设置一个只有一个人能获得的超级大奖。\n\n游戏规则如下：\n\n参与抽奖的总共有m人，按照1-m号围成一个大圈。\n\n从编号1开始报数，当报到N的时候，将该人淘汰。然后从下一个人开始，继续从1开始报数，到N时被淘汰，直到只剩一人时，获得大奖。\n\n如果你想获得大奖，你得在第一时间 抢占哪个编号才行？\n\n## 输入\n输入只有一行 包含两个整数  分别为m和n\nM代表参赛的总人数 所有人按照1-M编号\nN代表疏导N时被淘汰 \n\n\n1<m<0x7fffffff\n1<n<0x7fffffff\n\n## 输出\n输出最终会获胜的那个编号\n\n## 样例输入\n10 7\n## 样例输出\n9\n## 提示\n输入m可能是一个非常大的数值 这个时候怎么才能快速找到结果\n该题中包含了 可能需要使用复杂度为 O（N）的方法才能在满足时间和内存的条件下，获得结果\n\n如果只能完成50% 可以尝试已在在 m*n 大于  10^10的情况下 程序是否能在5秒内完成\n\n## 解析\n本题是约瑟夫环的一个考察，如果直接保存每一个人的状态按照顺序一步步模拟的话，会因为超时或者内存超限导致失败。\n使用递归需要注意递归有爆栈的风险。\n\n。。。\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n    只要 m >> n，算法的时间复杂度就只有 O(1) ，否则就退化为原来的递归算法\n*/\nint f1(int m, int n) {\n    int result = 1;\n    int del;\n    for (int i = 2; i <= m; i++){\n        if (result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n - 1) % i + 1;\n    }\n    return result;\n}\n/**\n    递归式:\n    f(1)=0; 第一个位置永远为0\n    f(i)=f(i)+m%n;\n*/\nint f2(int m, int n){\n    int result = 0;\n    int del;\n    for (int i=2; i<= m; i++){\n        if(result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n/**\n    f3/f4 方法类似\n*/\nint f3(int m, int n){\n    int result = 0;\n    for (int i=2; i<= m; i++){\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n\nint f4(int m, int n){\n    int result = 1;\n    for(int i=2; i<=m; i++){\n        result = (result + n - 1)%i + 1;\n    }\n    return result;\n}\n/**\n    递归暴力解题，输入m = 10w就会爆栈\n*/\nint f5(int m, int n) {\n    if(m == 1) {\n        return 0;\n    } else {\n        return (f3(m-1, n) + n) % m;\n    }\n}\n\nint main(){\n    int m,n;\n\n    cin>>m>>n;\n\n    cout<<f1(m,n)<<endl;\n\n    cout<<f2(m,n)<<endl;\n\n    cout<<f3(m,n)<<endl;\n\n    cout<<f4(m,n)<<endl;\n\n    cout<<f5(m,n)<<endl;\n\n}\n```\n', NULL, '1', '', 1, 0, 0, '2023-01-25 10:56:33', '2023-01-25 10:56:33');
INSERT INTO `article` VALUES (49, 1, '【公司】最长子串问题-双指针解法', '\n## 题目描述\n产品业务较复杂时，用户程序在实现某一个特定功能时，往往需要与底层模块进行多次交互，然后组合获取的底层结果，最终完成用户功能。\n\n实际上，一个底层模块，由于自身框架设计等原因，导致对外协议接口使用上会存在很多限制，用户程序需要严格根据底层模块的协议来进行交互。\n\n假设存在底层模块，对外提供n种不同交互命令X，编号依次为X1，...，Xn，互不相等，\n\n模块具有如下限制：模块先对接收到的命令进行过滤，提取序列中最长的没有重复的命令序列，如n=7，应用下发命令序列如下：\n\nX1 X2 X3 X1 X5 X4 X2 X5 X7 X6 X1 X3 X2 X3 \n\n\n因此该序列中，最长的没有重复有效命令序列为  X4 X2 X5 X7 X6 X1 X3 ，即最多命令数为 7\n\n简化上述过程，求解出 应用有效命令序列中最多命令数？\n\n## 解析\n题目大概就是求最长不重复子串（子串：原序列中必须连续的一段；子序列：原序列中可以不连续的一段），我这里采用的方法是双指针\n\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/f89b5fef965534bbe79b87bdc7cced71.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/c22f22b74c3de9aa916e53e5edbee783.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/327b2aa05c7ba564af493ded610a537b.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/0b810aeb48d8ab236cfa61be56b277a7.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/281e3e856ce039032172e904ebe462a0.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/2e39d2018f01d93a6bf4521356dd86b5.png?imageView2/2/w/1620\n\n![1](https://ask.qcloudimg.com/http-save/yehe-8271427/f89b5fef965534bbe79b87bdc7cced71.png?imageView2/2/w/1620)\n![2](https://ask.qcloudimg.com/http-save/yehe-8271427/c22f22b74c3de9aa916e53e5edbee783.png?imageView2/2/w/1620)\n![3](https://ask.qcloudimg.com/http-save/yehe-8271427/327b2aa05c7ba564af493ded610a537b.png?imageView2/2/w/1620)\n![4](https://ask.qcloudimg.com/http-save/yehe-8271427/0b810aeb48d8ab236cfa61be56b277a7.png?imageView2/2/w/1620)\n![5](https://ask.qcloudimg.com/http-save/yehe-8271427/281e3e856ce039032172e904ebe462a0.png?imageView2/2/w/1620)\n![6](https://ask.qcloudimg.com/http-save/yehe-8271427/2e39d2018f01d93a6bf4521356dd86b5.png?imageView2/2/w/1620)\n\n```c++\n// 本蒟蒻的解法\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n// 公司题目里面没说n的取值范围\nint arr[10010];\nint main(){\n    scanf(\"%d\",&N);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d\",&arr[i]);\n    }\n    // s表示头指针，e表示尾指针，l记录结果\n    int s=0,l=1;\n    for(int e=0; e<N; e++) {\n        for(int j=s; j<e; j++) {\n            if(arr[j] == arr[e]){\n                s = j+1;\n            }\n        }\n        l = max(l, e-s+1);\n    }\n    printf(\"%d\\n\", l);\n}\n```\n\n```c++\n// 大佬的解法Orz\n# include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint arr[100010], s[100010];\nint N;\n\nint main(){\n    int l=1;\n    scanf(\"%d\", &N);\n    for (int i=0,j=0; i<N; i++){\n        scanf(\"%d\",&arr[i]);\n        ++ s[arr[i]];\n        while (s[arr[i]] > 1) -- s[arr[j++]];\n        l = max(l, i-j+1);\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n```', NULL, '1', '', 1, 0, 0, '2023-01-25 10:57:49', '2023-01-25 11:00:43');
INSERT INTO `article` VALUES (50, 1, '【洛谷】P2820 并查集', '## 题目\n某个局域网内有 n(n≤100) 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 f(i,j) 表示 i,j 之间连接的畅通程度，f(i,j) 值越小表示 i,j 之间连接越通畅，f(i,j) 为 0 表示 i,j 之间无网线连接。\n## 题目描述\n需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的 ∑f(i,j) 最大，请求出这个最大值。\n## 输入格式\n第一行两个正整数 n,k。\n接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。\n## 输出格式\n一个正整数，∑f(i,j) 的最大值。\n\n## 解析\n根据题目可知，局域网是全部联通的，只是有多余线路导致整个网络形成了回路，要求出被除去网线的 ∑f(i,j)，也就是要使用最少的 ∑f(i,j) ，将网络连接起来（把 ∑f(i,j) 看作俩台电脑之间所连网线的长度会好理解一些），所以我可以先把所有电脑网线都拔开，然后使用最短的网线将这些电脑连接起来，剩余的网线长度就是被除去网线长度的最大值。\n\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N,K;\n// 用来记录输入的结构体\nstruct cpt{\n    int x,y,l;\n};\n// 100台电脑最大连接数量也就是4950，下标从1开始，所以4951刚刚好\nstruct cpt c[4951];\n// 使用并查集，用来记录每台电脑的上级，下标从1开始\nint par[101];\n// 并查集find函数，用来寻找某节点的上级\nint find1(int x) {\n    int r=x;\n    // 寻找该节点的上级，直到找到一个节点的上级就是自己退出循环\n    while(par[r]!=r){\n        r=par[r];\n    }\n    // 此处 r 表示传入 x 的最上级\n    int i=x,j;\n    // 压缩路径，将传入 x 的上级设为 r\n    while(i!=j){\n        j=par[r];\n        par[i]=j;\n        i=j;\n    }\n    return r;\n}\n// 并查集join函数，用来将新的节点加入网络\nvoid join(int x, int y) {\n	// 如果上级不一样，修改设置为相同\n    int fx=find1(x), fy=find1(y);\n    if(fx!=fy){\n        par[fx]=fy;\n    }\n}\n// 检查par数组中有几个区块（有几个上级为自己的节点）\nint check(){\n    int sum = 0;\n    for(int i=1; i<=N; i++)\n        if(par[i]==i)\n            sum ++;\n    return sum;\n}\n// 使用快排的cmp，从小到大\nbool cmp(cpt a, cpt b){\n    return a.l<b.l;\n}\n\nint main(){\n	// 用来记录网络中网线的最大长度\n    int length=0;\n    scanf(\"%d%d\",&N,&K);\n    for(int i=1; i<=N; i++)\n        par[i]=i;	// 设置每台电脑的上级都为自己\n    for(int i=1; i<=K; i++){\n        scanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].l);\n        // 记录网线长度\n        length+=c[i].l;\n    }\n    // 将所有节点之间的连接按照网线长度进行排序\n    sort(c+1, c+1+K, cmp);\n    // 对所有网线进行循环\n    for(int i=1; i<=K; i++){\n        int r1 = find1(c[i].x);\n        int r2 = find1(c[i].y);\n        // 如果这两台电脑的上级不同，则使用网线将这俩个区块连接起来\n        // 上级不同说明这两台电脑之间没有连接，此时取出的网线长度还是从小到大排列的\n        // 所以使用这个网线连接可以确保使用的是最短的网线\n        if(r1 != r2){\n            join(c[i].x,c[i].y);\n            // 从总长度中减去使用的网线长度\n            length-=c[i].l;\n        }\n    }\n    // 剩余的长度即为最大长度\n    printf(\"%d\",length);\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-01-25 11:01:31', '2023-01-25 11:01:31');
INSERT INTO `article` VALUES (51, 1, 'MySQL学习(一):存储过程以及定时任务', '# 存储过程\n	首先在navcat事件中创建存储过程,然后再开始代码编写\n```sql\n# IN表示传入参数,多个参数逗号隔开 格式: IN <name> <type>\nCREATE DEFINER=`mysql`@`127.0.0.1` PROCEDURE `UPDATE_ONLINE_SUMMARY_BY_MONTH`(IN tableName varchar(100))\nBEGIN\n\n# DATE_FORMAT(date,format)函数 date:传入日期 format:输出格式\n# 输出格式: %Y 年,4位,y小写俩位 %m 月,m大写是英文名 %d 日,d大写有英文后缀,例22nd\n# NOW() 返回当前日期\nSET @myYear = DATE_FORMAT(NOW(), \'%Y\');\nSET @myMonth = DATE_FORMAT(NOW(), \'%m\');\n# CONCAT() 字符串拼接函数,多个字符串用逗号隔开\nSET @saveDate = CONCAT(@myYear,\'_\' , @myMonth - 1);\nIF @myMonth > 6 THEN\n	SET @delDate = CONCAT(@myYear, \'_\', @myMonth - 6);\nELSE\n	SET @delDate = CONCAT(@myYear - 1, \'_\', @myMonth + 6);\nEND IF;\n\n#删除六个月之前的表格\nSET @deleteTableName = CONCAT(\'DROP TABLE IF EXISTS `\' , tableName , \'_\', @delDate , \'`;\');\n# PREPARE基本用法\n# PREPARE stmt from \'你的sql语句\';\n# EXECUTE stmt (如果sql有参数的话, USING xxx,xxx); // 这里USING的只能是会话变量\n# 会话变量: 例: SET @变量=值\n# DEALLOCATE PREPARE stmt;  // 释放连接\nPREPARE stmt FROM @deleteTableName;\nEXECUTE stmt;\n \n#重命名上个月的表\nSET @renameTableName = CONCAT(\'rename table \' , tableName , \' to \' , tableName, \'_\' , @saveDate , \';\');\nPREPARE stmt FROM @renameTableName;\nEXECUTE stmt;\n# sql的if elseif 语句格式\nIF tableName = \'adm_chn_online_summary\' THEN\n	#创建新表\n	SET @createStr = CONCAT(\"CREATE TABLE `adm_chn_online_summary` (\n		`ID` bigint(20) NOT NULL AUTO_INCREMENT,\n		`DEVICE_CODE` varchar(50) NOT NULL COMMENT \'设备code\',\n		`CHANNEL_SEQ` int(10) NOT NULL COMMENT \'通道号\',\n		`ONLINE_SECOND` bigint(20) NOT NULL COMMENT \'在线时长,单位秒\',\n		`ONLINE_RATE` double(20,2) NOT NULL COMMENT \'每日在线率，小数点保留二位\',\n		`DATE` datetime NOT NULL COMMENT \'统计日期，用于分组\',\n		`SAVE_DATE` datetime NOT NULL COMMENT \'数据插入时间，保留数据生成的时间点\',\n		`DESCRIBE_LIST` mediumtext COMMENT \'用于前端展示数据，展示具体的时间点在线和离线状态\',\n		PRIMARY KEY (`ID`),\n		KEY `INDEX_DEVICE_CODE` (`DEVICE_CODE`) USING BTREE,\n		KEY `INDEX_DATE` (`DATE`) USING BTREE\n	) ENGINE=InnoDB AUTO_INCREMENT=222357 DEFAULT CHARSET=utf8;\");\n	PREPARE stmt FROM @createStr;\n	EXECUTE stmt;\nELSEIF tableName = \'adm_dev_online_summary\' THEN\n	#创建新表\n	SET @createStr = CONCAT(\"CREATE TABLE `adm_dev_online_summary` (\n		`ID` bigint(20) NOT NULL AUTO_INCREMENT,\n		`DEVICE_CODE` varchar(50) CHARACTER SET utf8 NOT NULL COMMENT \'设备编号\',\n		`ONLINE_SECOND` bigint(20) NOT NULL COMMENT \'在线时长,单位秒\',\n		`ONLINE_RATE` double(20,2) NOT NULL COMMENT \'每日在线率，小数点保留二位\',\n		`DATE` datetime NOT NULL COMMENT \'统计日期，用于分组\',\n		`SAVE_DATE` datetime NOT NULL COMMENT \'数据插入时间，保留数据生成的时间点\',\n		`DESCRIBE_LIST` mediumtext CHARACTER SET utf8 COMMENT \'用于前端展示数据，展示具体的时间点在线和离线状态\',\n		PRIMARY KEY (`ID`)\n	) ENGINE=InnoDB AUTO_INCREMENT=24382 DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'设备在线时长统计表\';\");\n	PREPARE stmt FROM @createStr;\n	EXECUTE stmt;\nEND IF;\n\nDEALLOCATE PREPARE stmt;\nEND\n```\n\n# 定时任务\n```sql\nbegin\n\ncall UPDATE_ONLINE_SUMMARY_BY_MONTH(\'adm_chn_online_summary\');\ncall UPDATE_ONLINE_SUMMARY_BY_MONTH(\'adm_dev_online_summary\');\n\nend\n```\n然后在计划中添加执行时间', NULL, '5', '', 1, 0, 0, '2023-01-25 11:06:48', '2023-01-25 11:06:48');
INSERT INTO `article` VALUES (52, 1, 'Spring注解 @Scheduled', '# Scheduled注解中的cron表达式含义\ncron有6-7个用空格分开的时间元素\n## 时间元素\n| 字段 | 范围 | 允许的特殊值 |\n|--|--|-|\n| 秒 | 0-59 | , - * / |\n| 分 | 0-59 | , - * / |\n| 小时 | 0-59 | , - * / |\n| 日期 | 1-31 | , - * ? / L W C |\n| 月份 | 1-12(常用,也可以英文前三个字母) | , - * / |\n| 星期 | 1-7(常用,也可以SUN - SAT) | , - * ? / L C # |\n| 年(可选) | 1970-2099 | , - * / |\n\n```c\ncron表达式中6个元素依次分别表示: 秒, 分, 时, 日期, 月份, 星期, 年(可以省略)\n例1: 0 0 10,14 * * ?\n\'*\' 表示通配符,代表所有可能\n\'?\' \'?\'只用于日期和星期,因为星期和日期会冲突,所以必须有一个为\'?\'\n\',\' 表示一个列表,所以表达式为每天10点和下午2点\n例2: 0 0 10-14 * * ?\n\'-\' 表示一个连续区间,所以表达式为每天10点到下午2点\n例3: 0 0 10-14/1 * * ?\n\'/\' 表示间隔时间,所以表达式为每天10点到下午2点每隔1个小时\n例4: 0 0/5 10 * * ?\n0/15 表示从0分钟开始增量为15,和 0,15,30,45 含义一样\n3-15 表示从第3分钟开始增量为15,\'/\'左边不是必须为0或者一个连续区间\n表达式意思为: 每天10点到10:59之间每隔5分钟触发\n例5: 0 15 10 ? * 6L\n\'L\' 表示最后,last的简写,所以表达式意思是: 每个月最后一个周五的10:15分开始执行\n至于为什么6L是最后一个周五,是因为星期是 7 1 2 3 4 5 6 顺序排列,所以6表示周五\n例6: 0 0 12 W * ?\n\'W\' 表示工作日,所以表达式为每个工作日的12点\n\'LW\' 连用即表示最后一个工作日\n\'C\' 指和calendar联系后计算过的值 例：在日期字段用“5C”指在这个月第5天或之后包括calendar的第一天,在星期字段用“1C”指在这周日或之后包括calendar的第一天,因为不会用所以不写示例\n例7: 0 15 10 ? * 6#3 \n\'#\' 用于确定每个月的第几个星期几,只出现在星期字段中, #后面是第几个,前面是星期几 所以表达式为每个月第三个星期五的10点15分\n```\nhttps://www.jianshu.com/p/1979cadc0dd0', NULL, '6,7', '', 1, 0, 0, '2023-01-25 11:08:14', '2023-01-25 11:08:14');
INSERT INTO `article` VALUES (53, 1, 'Centos7安装MongoDB-5.0.2', '@[TOC](目录)\n# 1.下载MongoDB安装包\n下载 [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)\n选择MongoDB Community Server\nVersion：5.0.2（current）\nPlatform：RedHat / CentOS 7.0\nPackage：tgz\n安装位置：/usr/local/mongodb\n```shell\n# 进入指定位置下载安装包\ncd /usr/local\n# 下载安装包\nwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.2.tgz\n# 解压安装包\ntar -zxvf mongodb-linux-x86_64-rhel70-5.0.2.tgz\n# 改名字\nmv mongodb-linux-x86_64-rhel70-5.0.2 mongodb\n# 此时可以删除安装包\nrm -rf mongodb-linux-x86_64-rhel70-5.0.2.tgz \n```\n# 2.配置环境变量\n```shell\n# 配置环境变量\nvim /etc/profile\n\n## 文件中写入\nexport MONGO_HOME=/usr/local/mongodb\nexport PATH=$PATH:$MONGO_HOME/bin;\n## 然后按下shift+俩次 z 键，保存输入信息\n# 更新\nsource /etc/profile\n```\n# 3.建立日志、数据文件夹、配置文件夹\n```shell\n# 在 /usr/local/mongodb 路径下创建，如果不是需要切换进入\ncd /usr/local/mongodb\n# 创建三个文件夹\nmkdir logs data conf\n# 进入conf文件夹（写全路径防止大家走错位置）\ncd /usr/local/mongodb/conf\n# 写配置文件信息\nvim mongodb.conf\n## 内容如下\nport=27017 #端口\nbind_ip=0.0.0.0 #默认是127.0.0.1\ndbpath=/usr/local/mongodb/data #数据库存放\nlogpath=/usr/local/mongodb/logs/mongodb.log #日志文件\nfork=true #设置后台运行\n#auth=true #开启认证\n```\n# 4.启动MongoDB\n```shell\n# 启动命令\n./mongod --config /usr/local/mongodb/conf/mongodb.conf\n# 此处.conf文件路径一定不能出错\n```\n# 5.连接\n```shell\n# 输入mongo即可\nmongo\n```', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:10:32', '2023-01-25 11:10:32');
INSERT INTO `article` VALUES (54, 1, 'Centos7安装MySQL-5.7', '# 一、安装MySQL源\n```shell\n# 下载mysql安装包\nwget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n# 安装源\nyum -y localinstall mysql57-community-release-el7-11.noarch.rpm\n```\n# 二、yum安装MySQL\n```shell\n yum -y install mysql-community-server\n```\n# 三、启动MySQL服务\n```shell\nsystemctl start mysqld\n```\n\n# 四、设置开机启动\n```\nsystemctl enable mysqld\nsystemctl daemon-reload\n```\n# 五、登录MySQL\n	查看MySQL密码\n```shell\ncat /var/log/mysqld.log\n```\n	登录密码为下图所示位置密码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fad16c42ce41475c8a0a10313a171208.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JKfLeiSuw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n```sql\nmysql -u root -p\n```\n# 六、修改MySQL密码\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'root\'; \n```\n如果提示报错：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements \n则需要修改MySQL的密码策略\n因为不修改密码不允许查看密码策略，所以需要先符合密码策略修改一次\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'MySQL123@*\'; \n```\n\n## 1、查看 mysql 初始的密码策略，\n输入语句以下进行查看，\n```sql\nSHOW VARIABLES LIKE \'validate_password%\';\n```\n```\n1）、validate_password_length  固定密码的总长度；\n2）、validate_password_dictionary_file 指定密码验证的文件路径；\n3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；\n4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；\n5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；\n关于 validate_password_policy 的取值：\n0/LOW：只验证长度；\n1/MEDIUM：验证长度、数字、大小写、特殊字符；\n2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；\n6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；\n```\n## 2、设置密码的验证强度等级\n	设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句\n```sql\nset global validate_password_policy=LOW;\n```\n\n## 3、当前密码长度为4\n	可以根据自己相关自定义密码长度，输入设值语句\n```sql\nset global validate_password_length=4;\n```\n\n## 4、修改MySQL密码\n	现在可以为 mysql 设置简单密码了，只要满足四位的长度即可，可自己修改\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'root\';\n```\n\n# 七、设置远程登陆\n	by之后为远程登陆密码，和本地登陆密码不冲突，123456需自定义修改\n```sql\ngrant all on *.* to root@\'%\' identified by \'123456\' with grant option;\n```', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:11:47', '2023-01-25 11:11:47');
INSERT INTO `article` VALUES (55, 1, 'Centos7安装redis-6.2.5', '# 安装redis-6.2.5\n\n```shell\n# 安装到指定文件夹\ncd /usr/local/\n# 获取redis安装包\nwget https://download.redis.io/releases/redis-6.2.5.tar.gz\n# 解压\ntar -zxvf redis-6.2.5.tar.gz\n# 改名字\nmv redis-6.2.5 redis\n# 进入redis文件夹\ncd redis\n# 执行make命令\nmake\n```\n\n# redis启动\n## 方式一：\n\n```shell\n# 进入src目录\ncd /usr/local/redis/src/\n./redis-server\n```\n缺点：需要一直打开窗口，不能进行其他操作，不太方便\n## 方式二：\n```shell\n# 进入redis文件目录\ncd /usr/local/redis\n# 修改redis配置文件\nvim redis.conf \n# 修改daemonize 选项\n# 将 daemonize no 改为 daemonize yes\n# 进入redis启动文件目录\ncd /usr/local/redis/src\n# 指定redis.conf文件启动\n./redis-server /usr/local/redis/redis.conf\n```\n推荐', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:00', '2023-01-25 11:48:14');
INSERT INTO `article` VALUES (56, 1, 'Centos7安装tomcat-10.0.11', '# Tomcat安装包下载\n\n```shell\n# 进入要安装的文件夹\ncd /usr/local\n# 从官网下载tomcat安装包\nwget https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.11/bin/apache-tomcat-10.0.11.tar.gz\n# 解压安装包\ntar -zxvf apache-tomcat-10.0.11.tar.gz\n# 改个名字\nmv apache-tomcat-10.0.11 tomcat\n# 启动tomcat（要配置好jdk）\ncd tomcat/bin/\n./startup.sh \n# 如果启动成功了，但是自己电脑访问不到 ip:8080页面可能是因为防火墙的原因\n# 放行8080端口\nsystemctl start firewalld\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\n```\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:24', '2023-01-25 11:14:24');
INSERT INTO `article` VALUES (57, 1, 'Centos安装jdk-17', '# 下载jdk包\n\n```shell\n# 在 /usr/local 目录下安装jdk\ncd /usr/local\nwget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz\ntar -zxvf jdk-17_linux-x64_bin.tar.gz \n# 将jdk-17改名为java\nmv jdk-17 java\n```\n\n\n# 添加环境变量\n\n```shell\n# 进入profile文件，按i进入编辑模式\nvim /etc/profile\n# 在文件最下方添加\nexport JAVA_HOME=/usr/local/java\nexport PATH=$PATH:$JAVA_HOME/bin;\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar;\n# 按下Esc退出编辑模式\n# 下一步按住shift 再按俩次 z 键，保存配置文件信息\n# 重新加载环境变量\nsource /etc/profile\n# \ncd /\njava -version\n```\n\n\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:48', '2023-01-25 11:14:48');
INSERT INTO `article` VALUES (58, 1, 'Mybatis使用笔记（一）', '# 前言\n```xml\n	<resultMap id=\"BaseResultMap\" type=\"com.spring.demo.entity.Student\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n    </resultMap>\n\n    <sql id=\"All_Menu\">\n        id, student_name, student_sex, student_class, student_age\n    </sql>\n```\n# 查询\n\n```xml\n	<!--无参数-->\n    <select id=\"selectAll\" resultMap=\"BaseResultMap\">\n        select\n        <include refid=\"All_Menu\"/>\n        from student_table\n    </select>\n\n	<!--有参数-->\n    <select id=\"selectById\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Integer\">\n        select\n        <include refid=\"All_Menu\"/>\n        from student_table\n        where id = #{id, jdbcType=INTEGER}\n    </select>\n```\n\n# 修改\n```xml\n    <update id=\"updateById\" parameterType=\"com.spring.demo.entity.Student\">\n        update student_table\n        <set>\n            <if test=\"studentName != null and studentName != \'\'\">\n                student_name = #{studentName},\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                student_sex = #{studentSex},\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                student_class = #{studentClass},\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                student_age = #{studentAge},\n            </if>\n        </set>\n        <where>\n            id = #{id}\n        </where>\n    </update>\n```\n# 插入\n```xml\n	<!--插入一个学生信息-->\n    <insert id=\"insertStudent\" parameterType=\"com.spring.demo.entity.Student\">\n        insert into student_table\n        <trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n            <if test=\"studentName != null and studentName != \'\'\">\n                student_name,\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                student_sex,\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                student_class,\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                student_age,\n            </if>\n        </trim>\n        <trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n            <if test=\"studentName != null and studentName != \'\'\">\n                #{studentName, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                #{studentSex, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                #{studentClass, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                #{studentAge, jdbcType=VARCHAR},\n            </if>\n        </trim>\n    </insert>\n	<!--插入一个学生信息列表-->\n    <insert id=\"insertStudentList\">\n        insert into student_table (student_name, student_sex, student_class, student_age)\n        values\n        <foreach collection=\"list\" item=\"item\" separator=\",\">\n            (#{item.studentName}, #{item.studentSex},\n            #{item.studentClass}, #{item.studentAge})\n        </foreach>\n    </insert>\n```\n# 删除\n```xml\n    <!--通过id删除信息-->\n    <delete id=\"deleteStudentById\" parameterType=\"java.lang.Integer\">\n        delete from student_table where id = #{id}\n    </delete>\n    <!--传入List删除-->\n    <delete id=\"deleteByIdList\" parameterType=\"java.util.List\">\n        delete from student_table\n        where id in (\n        <foreach collection=\"list\" item=\"id\" index=\"index\" separator=\",\">\n            #{id}\n        </foreach>\n        )\n    </delete>\n```\n\n# 其它\n## resultType和resultMap的区别：\nresultType是简单的返回类型，比如查询数据只需要一个简单的String、int只需要使用resultType即可满足需求，\nresultMap是resultType的高级版，可以自定义返回类型\n### resultMap：\ncolumn对应数据库中的字段名字，property对应实体类的名字\n## 输入映射parameterType：\n可以传入8种基本数据类型，pojo类型，包装pojo类型（pojo类型再次封装），传入map（在映射文件中获取对应的key， #{key}）\n', NULL, '10,12', '', 1, 0, 0, '2023-01-25 11:16:18', '2023-01-25 11:42:38');
INSERT INTO `article` VALUES (59, 1, 'Mybatis使用笔记（二）', '# Mybatis查询之resultMap的使用\n\n使用result的高级功能，一对一映射、一对多映射以及多对多映射\n一对一映射对应的标签为association，一对多映射对应的标签为collection\n一对一映射使用包装对象实现，例如：要查找学生和班级，但是学生信息以及班级信息在两个类中，可以将班级类型作为一个对象包装进入学生类中\n```java\n@Data\npublic class Student {\n    private Integer id;\n    private String studentName;\n    private String studentSex;\n    private Integer studentClass;\n    private Integer studentAge;\n\n    private ClassEntity classEntity;\n}\n```\nassociation和collection二者标签的内部属性基本是一致的，它们的属性介绍如下：\n\n - （常用）property：映射 实体类属性名。 \n - （常用）column：映射数据库字段名或者其别名（这个别名是数据库起的，如 select username as name）。\n - （常用）javaType：映射java类型。 \n - （常用）jdbcType：映射数据库类型。\n - （常用）ofType：映射集合的类型（注意：javaType是用来指定pojo中属性的类型，而ofType指定的是映射到list集合属性中pojo的类型，也就是尖括号的泛型private List<User> users）。 \n - （常用）select：用于加载复杂类型属性的映射语句的id(全限定名加方法，方法名后面无括号，例如：com.thr.mapper.UserMapper.selectAllUser)，它会从column 属性指定的列中检索数据，作为参数传递给目标 select 语句。\n - （常用）fetchType：延迟加载，lazy打开延迟加载，eager积极加载。指定属性后，将在映射中忽略全局配置参数lazyLoadingEnabled，使用属性的值。\n - resultMap：不使用嵌套模式，而是将此关联的嵌套结果集映射到一个外部的<resultMap>标签中，然后通过 id 进行引入。\n - resultSet：指定用于加载复杂类型的结果集名字。\n - autoMapping：自动封装，如果数据库字段和javaBean的字段名一样，可以使用这种方式，但是不建议采取，如果非要使用此功能，那就在全局配置中加上mapUnderscoreToCamelCase=TRUE，它会使经典数据库字段命名规则翻译成javaBean的经典命名规则，如：a_column翻译成aColumn。\n - columnPrefix：关联多张表查询时，为了使列明不重复，使用此功能可以减少开发量。\n - foreignColumn：指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。\n - notNullColumn：不为空的列，如果指定了列，那么只有当字段不为空时，Mybatis才会真正创建对象，才能得到我们想要的值。\n - typeHandler：数据库与Java类型匹配处理器（可以参考前面的TypeHandler部分）。\n\n# 一对一映射\n## 嵌套查询\n映射xml语句\n```xml\n    <resultMap id=\"StudentClassMap\" type=\"com.spring.demo.entity.Student\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <!--一对一关联对象-->\n        <!--property：映射实体类属性名字-->\n        <!--javaType：映射Java类型-->\n        <association property=\"classEntity\" javaType=\"com.spring.demo.entity.ClassEntity\">\n            <!--property和column表示映射实体类和其表中字段绑定-->\n            <!--此处有一个小问题，就是如果id为 <id property=\"id\" column=\"id\"/> 时，会出现查询结果中的id是学生的id，className没有错误-->\n            <id property=\"classId\" column=\"class_id\"/>\n            <result property=\"className\" column=\"class_name\"/>\n        </association>\n    </resultMap>\n    <!--查询所有数据-->\n    <select id=\"selectStudentClass\" resultMap=\"StudentClassMap\">\n        select * from\n        student_table s,\n        class_table c\n        where\n        s.student_class = c.class_id\n    </select>\n    <!--根据学生id查找其信息-->\n    <select id=\"selectStudentClassById\" parameterType=\"java.lang.Integer\" resultMap=\"StudentClassMap\">\n        select * from\n        student_table s,\n        class_table c\n        where\n        s.student_class = c.class_id\n        and s.id = #{id}\n    </select>\n```\n\n## 分布查询\n```xml\n    <!--分布查询-->\n    <resultMap id=\"StudentClassMap2\" type=\"com.spring.demo.vo.StudentVo\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <!--column为student表中班级字段， property为StudentVo类中班级类名，javaType为班级类，select指定通过id查询班级的接口-->\n        <association column=\"student_class\" property=\"classEntity\" javaType=\"com.spring.demo.entity.ClassEntity\"\n                    select=\"com.spring.demo.dao.ClassDAO.selectById\"/>\n\n    </resultMap>\n    \n    <select id=\"selectStudentClassById_\" parameterType=\"java.lang.Integer\" resultMap=\"StudentClassMap2\">\n        select * from\n        student_table\n        where\n        id = #{id}\n    </select>\n```\n```java\n// studentVo类\n@Data\n// 作用是在 json 序列化时忽略 bean 中的一些不需要转化的属性\n@JsonIgnoreProperties(value = { \"handler\" })\npublic class StudentVo {\n    private Integer id;\n    private String studentName;\n    private String studentSex;\n    private Integer studentClass;\n    private Integer studentAge;\n\n    private ClassEntity classEntity;\n}\n\n```\n## 总结\n分布查询会比嵌套查询多执行几个sql，所以效率上是嵌套查询更好，但是分布查询可以延迟加载（懒加载）\n\n# 一对多映射\n## 嵌套查询\n```xml\n    <resultMap id=\"ClassStudentMap\" type=\"com.spring.demo.vo.ClassEntityVo\">\n        <id column=\"class_id\" property=\"classId\"/>\n        <result column=\"class_name\" property=\"className\"/>\n        <!--一对多映射-->\n        <!--ofType：指定pojo的类型，为list尖括号内部的泛型-->\n        <collection property=\"students\" ofType=\"com.spring.demo.entity.Student\">\n            <id column=\"id\" property=\"id\"/>\n            <result column=\"student_name\" property=\"studentName\"/>\n            <result column=\"student_sex\" property=\"studentSex\"/>\n            <result column=\"student_age\" property=\"studentAge\"/>\n            <result column=\"student_class\" property=\"studentClass\"/>\n        </collection>\n    </resultMap>\n	<!--查询所有班级学生-->\n    <select id=\"selectClassStudent\" resultMap=\"ClassStudentMap\">\n        select * from\n        class_table c,\n        student_table s\n        where\n        c.class_id = s.student_class\n    </select>\n    <!--通过班级id查询班级学生-->\n    <select id=\"selectClassStudentById\" parameterType=\"java.lang.Integer\" resultMap=\"ClassStudentMap\">\n        select * from\n        class_table c,\n        student_table s\n        where\n        c.class_id = s.student_class\n        and c.class_id = #{classId}\n    </select>\n```\n\n## 分布查询\n```xml\n    <resultMap id=\"ClassStudentMap2\" type=\"com.spring.demo.vo.ClassEntityVo\">\n        <id column=\"class_id\" property=\"classId\"/>\n        <result column=\"class_name\" property=\"className\"/>\n        <collection column=\"class_id\" property=\"students\" ofType=\"com.spring.demo.entity.Student\"\n                    select=\"com.spring.demo.dao.StudentDAO.selectByClass\"/>\n    </resultMap>\n    \n    <!--分布查询，通过班级id查询班级学生-->\n    <select id=\"selectClassStudentById_\" parameterType=\"java.lang.Integer\" resultMap=\"ClassStudentMap2\">\n        select * from class_table\n        where class_id = #{classId}\n    </select>\n```', NULL, '10,12', '', 1, 0, 0, '2023-01-25 11:16:43', '2023-01-25 11:42:59');
INSERT INTO `article` VALUES (60, 1, 'Mybatis学习笔记（一）', '# Mybatis的基本概念\n\n - 持久化：将内存中的数据保存在存储设备中\n - 持久层：专注实现数据持久化应用领域的某个系统特定的一个逻辑层面，将数据使用者和数据实体相关联。例如pojo层、Dao层和Service层的关联\n - ORM：对象关系映射，将数据库中的数据与程序中的对象映射，操作数据库时只需要和对象打交道就行，简化了操作。Mybatis是一个半自动化的ORM框架，因为需要写sql语句，Hibernate是一个全自动化的ORM框架\n\n# Mybatis和Hibernate的区别\n## 开发方面\n\n - Hibernate是全自动的ORM映射工具，使用Hibernate查询关联对象或关联集合对象时，可以根据对象关系模型直接获取\n	\n - Mybatis是半自动ORM映射工具，Mybatis在查询关联对象或关联集合对象时需要手动编写sql来完成。Mybatis可以通过注解或XML的方式配置sql，并将java对象和sql语句映射生成最终执行的sql，然后再将结果映射生成Java对象\n\n## 底层\n - Hibernate的底层是JPA规范实现的\n - Mybatis是封装JDBC的代码\n\n## SQL优化方面\n\n - Hibernate自动生成sql相比Mybatis可能会多消耗一些性能\n \n \n## 对象管理方面\n - Hibernate是完整的对象/关系映射的框架，对象/关系映射能力极强，在开发过程中无需过多关注底层实现，只需要管理对象即可；而且数据库无关性好，对于关系模型要求高的软件使用Hibernate可以节省很多代码\n - Mybatis需要自己管理映射关系，并且无法做到数据库无关性，如果要支持多种数据库则需要自定义多套sql映射文件\n \n \n## 日志系统\n - Hibernate日志功能非常健全，Mybatis只有简单的基本记录功能\n \n ## 缓存\n \n - 之后写\n\n# Mybatis的重要组件\n![Mybatis结构](https://img-blog.csdnimg.cn/50615112756f43c59f86e28c8217ca98.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70#pic_center)\n\n - SqlMapConfig.xml：是Mybatis的全局配置文件，主要配置数据源、（事务、加载映射文件）\n - SqlSessionFactoryBuilder：根据xml配置或是Java配置生成SqlSessionFactory对象。采用建造者模\n - SqlSessionFactory：用于生成SqlSession，可以通过SqlSessionFactory.OpenSession()方法创建SqlSession对象。使用工厂模式\n	\n - SqlSession：相当于JDBC的Connection对象，可以用SqlSession实例来直接执行被映射的sql语句，也可以获取相应的Mapper\n	\n - Executor：Mybatis中所有的Mapper语句都是通过Executor执行的\n		\n - Mapper：由XML文件和Java接口组成，根据XML中配置的映射信息执行对应的sql语句并返回执行结果\n	\n - MappedStatement：作用是封装了Statement的相关信息，包括SQL语句、输入参数和输出结果等等\n\n\n\n# Mybatis执行流程\n\n - 首先加载Mybatis的全局配置文件，随后会加载sql映射文件或者注解相关的sql内容\n - 创建会话工厂，Mybatis通过读取配置文件的信息来构造出会话工厂 SqlSessionFactory\n - 创建会话，根据会话工厂Mybatis创建会话对象 SqlSession，会话对象是一个接口包括对数据库的增删改查方法\n - 创建执行器会话不能直接操作数据库，所以使用数据库执行器Executor的接口帮它执行操作\n - 封装sql对象，执行器将待处理的sql信息封装到一个对象中MappedStatement，该对象包括sql语句、输入参数映射信息和输出结果映射信息\n - 操作数据库使用执行器和sql封装对象查询数据库返回结果\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:17:32', '2023-01-25 11:43:07');
INSERT INTO `article` VALUES (61, 1, 'Mybatis学习笔记（二）', '# 前言\nMybatis的使用主要分三个版本\n\n - 基于原生接口的xml版本\n - 基于mapper接口的xml版本\n - 基于Java注解的版本\n\n在实际开发中主要使用基于mapper接口的版本，本章学习主要记录基于原生接口的版本\n\n# 创建数据库\n\n```sql\nDROP TABLE IF EXISTS `t_student`;\nCREATE TABLE `t_student`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `age` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Records of t_student\n-- ----------------------------\nINSERT INTO `t_student` VALUES (1, \'马保国\', \'男\', 44);\nINSERT INTO `t_student` VALUES (2, \'张三\', \'男\', 20);\nINSERT INTO `t_student` VALUES (3, \'李四\', \'男\', 30);\nINSERT INTO `t_student` VALUES (4, \'王五\', \'男\', 40);\nINSERT INTO `t_student` VALUES (5, \'赵六\', \'男\', 10);\nINSERT INTO `t_student` VALUES (6, \'孙七\', \'女\', 35);\nINSERT INTO `t_student` VALUES (7, \'周八\', \'女\', 20);\n\n```\n\n# 创建maven项目\n\n![项目文件](https://img-blog.csdnimg.cn/7da0e27f7ff04e61a6c2e43d42490eed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70#pic_center)\n\n\n\n导入pom依赖：\n\n```java\n    <dependencies>\n        <!--Mybatis-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.7</version>\n        </dependency>\n        <!--MySQL驱动-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.21</version>\n        </dependency>\n        <!--日志处理-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <!--单元测试-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n## 编写实体类\n```java\n/**\n * @author: lxk\n * @date: 2021/7/24 22:56\n * @description: 学生实体类\n * @modified By:\n */\npublic class Student {\n    private Integer id;\n    private String name;\n    private String sex;\n    private Integer age;\n	// get set 方法省略\n}\n```\n\n## 创建Mybatis全局配置文件\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    <!-- 配置环境.-->\n    <environments default=\"development\">\n        <!-- id属性必须和上面的default一致 -->\n        <environment id=\"development\">\n            <!--配置事务的类型-->\n            <transactionManager type=\"JDBC\"/>\n            <!--dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源 -->\n            <dataSource type=\"POOLED\">\n                <!--配置连接数据库的4个基本信息-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"mysql\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--指定映射配置文件的位置，这个映射配置文件指的是每个业务独立的配置文件-->\n    <mappers>\n        <mapper resource=\"mapper/StudentMapper.xml\"/>\n    </mappers>\n</configuration>\n\n```\n\n - **environments**：配置当前环境，default属性有development（开发模式 默认）和work（工作模式）两种选择\n - **environment**：配置environment定义的环境，可以配置多个运行环境，但每个SqlSessionFactory实例只能选择一个运行环境\n - **transactionManager**：配置事务管理器类型，type属性有JDBC和MANAGED两种\n**JDBC**使用JdbcTransactionFactory工厂生成的JdbcTranaction对象实现，以JDBC的方式进行数据库的提交回滚等操作，它依赖于从数据源得到的连接来管理事务范围\n **MANAGED**使用ManagedTransactionFactory工厂生成的ManagedTransaction对象实现，它的提交和回滚不需要任何操作，而是把事务交给容器进行处理，默认情况下会关闭连接，可以修改closeConnection属性为false不默认关闭\n - **dataSource**：配置数据源属性，type有UNPOOLED、POOLED和JNDI三种选择\n**UNPOOLED**：采用非数据库池的管理方式，每次请求都会新建一个连接，并且用完后会关闭，所以性能并不高\n		**POOLED**：采用连接池的概念将数据库链接对象Connection起来，可以在初始化的时候创建多个连接，使用时直接从连接池获取，避免重复创建连接的时间，效率较高\n		**JNDI**：数据源JNDI的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI的上下文引用，生产环境优先考虑\n - **property**：dataSource中的property元素就是数据库相关的配置信息\n - **mappers**：用来存放mapper的标签\n - **mapper**：映射文件资源位置，如下代码所示\n\n```xml\n<mappers>\n	<mapper resource=\"mapper/StudentMapper.xml\">\n</mappers>\n```\n\n## SQL映射文件\n\n - 命名空间用来设定当前配置文件的唯一标识，在Java程序中将通过namespace定位该配置文件，名字可以随便取，但是推荐用mapper的全类名\n - id：sql映射语句的唯一标识，称为statement的id，将sql语句封装到mappedStatement对象中，所以将id称为statement的id\n - parameterType: 指定输入参数类型\n - resultType: 指定输出结果类型。Mybatis将sql查询结果的一行记录映射为resultType指定对象，如果有多条则分别映射最后放入Lise容器\n - #{value}表示sql语句的占位符，相当于jdbc的？会自动进行jdbc类型和Java类型转换，不可以为空\n - ${value}表示拼接字符串，会导致sql注入\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!-- mapper标签是当前配置文件的根标签 -->\n<!-- namespace属性：表示命名空间，用来设定当前Mapper配置文件的唯一标识，将来在Java程序中通过namespace属性的值来定位到这个配置文件 -->\n<mapper namespace=\"com.th.entity.Student\">\n    <!-- 查询所有学生 -->\n    <select id=\"selectAllStudent\" resultType=\"com.th.entity.Student\">\n        select * from t_student;\n    </select>\n    <!-- 通过Id查询一个学生 -->\n    <select id=\"selectStudentById\" parameterType=\"int\" resultType=\"com.th.entity.Student\">\n        select * from t_student where id = #{id};\n    </select>\n    <!-- 模糊查询，根据name字段查询学生-->\n    <select id=\"selectStudentByName\" parameterType=\"int\" resultType=\"com.th.entity.Student\">\n        select * from t_student where s_name like \'%${value}%\';\n    </select>\n    <!-- 添加学生-->\n    <insert id=\"insertStudent\" parameterType=\"com.th.entity.Student\">\n        insert into t_student(s_name, age, sex)\n        values (#{s_name}, #{age}, #{sex});\n    </insert>\n    <!-- 根据Id更新学生 -->\n    <update id=\"updateStudent\" parameterType=\"com.th.entity.Student\">\n        update t_student set s_name = #{s_name},\n            age = #{age},sex = #{sex} where id = #{id};\n    </update>\n    <!-- 根据Id删除学生 -->\n    <delete id=\"deleteStudent\" parameterType=\"int\">\n        delete from t_student where id = #{id};\n    </delete>\n</mapper>\n\n\n```\n\n## 加载映射文件\n\n```xml\n\n    <!--指定映射配置文件的位置，这个映射配置文件指的是每个业务独立的配置文件-->\n    <mappers>\n        <mapper resource=\"mapper/StudentMapper.xml\"/>\n    </mappers>\n```\n\n\n## 日志与测试类\n```yml\n\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog4j.appender.LOGFILE=org.apache.log4j.FileAppender\nlog4j.appender.LOGFILE.File=F:/axis.log\nlog4j.appender.LOGFILE.Append=true\nlog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n\n```\n\n```java\n\npackage com.th.test;\n\n/**\n * @author: lxk\n * @date: 2021/7/24 22:57\n * @description: Mybatis测试类\n * @modified By:\n */\n\nimport com.th.entity.Student;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n * Mybatis的测试\n */\n\n/**\n * Mybatis的测试\n */\npublic class MybatisTest {\n    //定义 SqlSession\n    SqlSession sqlSession = null;\n\n    @Before\n    public void getSqlSession() {\n        //加载 mybatis 全局配置文件\n        InputStream is = MybatisTest.class.getClassLoader().getResourceAsStream(\"mybatis-config.xml\");\n        //创建 SqlSessionFactory 对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        //根据 sqlSessionFactory 产生 session\n        sqlSession = sqlSessionFactory.openSession();\n    }\n\n    //查询所有用户数据\n    @Test\n    public void testSelectAllStudent() {\n        /**\n         * 注意：这个字符串由 UserMapper.xml 文件中的两个部分构成(namespace + id)\n         * <mapper namespace=\"com.thr.mapper.UserMapper\">中 namespace 的值\n         * <select id=\"selectAllUser\" > 中的 id 值\n         * 这样Mybatis才能找到需要的SQL\n         */\n        String statement = \"com.th.entity.Student.selectAllStudent\";\n        List<Student> listStudent = sqlSession.selectList(statement);\n        for (Student student : listStudent) {\n            System.out.println(student.toString());\n        }\n        sqlSession.close();\n    }\n\n    //根据Id查询一个用户数据\n    @Test\n    public void testSelectStudentById() {\n        String statement = \"com.th.entity.Student.selectStudentById\";\n        Student student = sqlSession.selectOne(statement, 1);\n        System.out.println(student.toString());\n        sqlSession.close();\n    }\n\n    //模糊查询：根据 user 表的username字段\n    @Test\n    public void testSelectStudentByName() {\n        String statement = \"com.th.entity.Student.selectStudentByName\";\n        List<Student> listStudent = sqlSession.selectList(statement, \"三\");\n        for (Student student : listStudent) {\n            System.out.println(student.toString());\n        }\n        sqlSession.close();\n    }\n\n    //添加一个用户数据\n    @Test\n    public void testInsertStudent() {\n        String statement = \"com.th.entity.Student.insertStudent\";\n        Student user = new Student();\n        user.setS_name(\"张三丰\");\n        user.setAge(34);\n        user.setSex(\"男\");\n        int i = sqlSession.insert(statement, user);\n        System.out.println( (i>0)? \"添加成功！\":\"添加失败！\");\n        //提交插入的数据\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    //根据Id修改用户数据\n    @Test\n    public void testUpdateStudent(){\n        //如果设置的 id不存在，那么数据库没有数据更改\n        String statement = \"com.th.entity.Student.updateStudent\";\n        Student user = new Student();\n        user.setId(3);\n        user.setS_name(\"王红\");\n        user.setAge(26);\n        user.setSex(\"女\");\n        int i = sqlSession.update(statement, user);\n        System.out.println( (i>0)? \"修改成功！\":\"修改失败！\");\n        //提交数据\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    //根据Id删除用户数据\n    @Test\n    public void testDeleteStudent(){\n        String statement = \"com.th.entity.Student.deleteStudent\";\n        int i = sqlSession.delete(statement, 4);\n        System.out.println( (i>0)? \"删除成功！\":\"删除失败！\");\n        sqlSession.commit();\n        sqlSession.close();\n    }\n}\n\n\n\n```\n\n\n\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:18:58', '2023-01-25 11:42:51');
INSERT INTO `article` VALUES (62, 1, 'Mybatis学习笔记（三）', '# 全局配置文件\n配置文件内顺序不能改\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n \n<configuration> <!--配置-->\n    <properties/> <!--属性-->\n    <settings/> <!--全局配置参数-->\n    <typeAliases/> <!--类型别名-->\n    <typeHandlers/> <!--类型处理器-->\n    <objectFactory/><!--对象工厂-->\n    <plugins/><!--插件-->\n    <environments default=\"\"><!--环境配置-->\n        <environment id=\"\"><!--环境变量-->\n            <transactionManager type=\"\"/><!--事务管理器-->\n            <dataSource type=\"\"/><!--数据源-->\n        </environment>\n    </environments>\n    <databaseIdProvider type=\"\"/><!--数据库厂商标识-->\n    <mappers/><!--映射器-->\n</configuration>\n```\n\n# properties属性\n作用：引用Java属性文件中的配置信息\n\nmybatis提供三种方式配置properties属\n 1. property子元素 (影响配置文件整洁)\n```xml\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n \n<configuration>\n    <properties>\n        <!--property子元素定义-->\n        <property name=\"database.driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"database.url\" value=\"jdbc:mysql://localhost:3306/user?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8\"/>\n        <property name=\"database.username\" value=\"root\"/>\n        <property name=\"database.password\" value=\"root\"/>\n    </properties>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <dataSource type=\"POOLED\">\n                <!--配置连接数据库的4个基本信息-->\n                <property name=\"driver\" value=\"${database.driver}\"/>\n                <property name=\"url\" value=\"${database.url}\"/>\n                <property name=\"username\" value=\"${database.username}\"/>\n                <property name=\"password\" value=\"${database.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n 2. properties文件\n\n```xml\n创建一个叫database.properties的配置文件，写入如下代码\n#数据库连接配置\ndatabase.driver=com.mysql.cj.jdbc.Driver\ndatabase.url=jdbc:mysql://localhost:3306/user?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8\ndatabase.username=root\ndatabase.password=root\n然后在Mybatis配置文件中使用<properties>元素的resource属性来引入properties文件\n<properties resource=\"database.properties\" />\n\n```\n\n\n3. 程序代码传递参数\n\n```java\npublic static SqlSessionFactory getSqlSessionFactoryByXml() {\n        synchronized (Lock) {\n            if (null != sqlSessionFactory) {\n                return sqlSessionFactory;\n            }\n            String resource = \"mybatis-config.xml\";\n            InputStream inputStream;\n            InputStream is = null;\n            try {\n                // 加载数据库配置文件\n                is = Resources.getResourceAsStream(\"database.properties\");\n                Properties properties = new Properties();\n                properties.load(is);\n \n                // 获取加密信息\n                String username = properties.getProperty(\"database.username\");\n                String password = properties.getProperty(\"database.password\");\n \n                // 解密用户名和密码，并重置属性\n                properties.setProperty(\"database.username\", CyperTool.decodeByBase64(username));\n                properties.setProperty(\"database.password\", CyperTool.decodeByBase64(password));\n                // 读取mybatis配置文件\n                inputStream = Resources.getResourceAsStream(resource);\n                // 通过SqlSessionFactoryBuilder类的builder方法进行构建，并使用程序传递的方式覆盖原有属性\n                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, properties);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n            return sqlSessionFactory;\n        }\n    }\n\n```\n使用synchornized锁保证数据的准确性\n	代码逻辑：\n	\n首先使用 Resources获取database.properties配置文件，\n\n然后获取它原来配置的用户和密码进行解密操作，\n\n最后使用SqlSessionFactoryBuilder的build方法传递多个properties参数覆盖之前的加密配置\n\n# settings属性\n```xml\n<settings>\n    <!--缓存配置的全局开关：如果这里设置成false，那么即便在映射器中配置开启也无济于事 -->\n    <setting name=\"cacheEnabled\" value=\"true\" />\n    <!--延时加载的全局开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"false\" />\n    <!-- 是否允许单一语句返回多结果集 -->\n    <setting name=\"multipleResultSetsEnabled\" value=\"true\" />\n    <!-- 使用列标签代替列名，需要兼容驱动 -->\n    <setting name=\"useColumnLabel\" value=\"true\" />\n    <!-- 允许JDBC自动生成主键，需要驱动兼容。如果设置为true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍能正常工作 -->\n    <setting name=\"useGeneratedKeys\" value=\"false\" />\n    <!-- 指定MyBatis该如何自动映射列到字段或属性：NONE表示取消自动映射；PARTIAL表示只会自动映射，没有定义嵌套结果集和映射结果集；\n    FULL会自动映射任意复杂的结果集，无论是否嵌套 -->\n    <setting name=\"autoMappingBehavior\" value=\"PARTIAL\" />\n    <!-- 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志FAILING: 映射失败 (抛出 SqlSessionException) -->\n    <setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\" />\n    <!-- 配置默认的执行器：SIMPLE是普通的执行器；REUSE会重用预处理语句；BATCH会重用语句并执行批量更新 -->\n    <setting name=\"defaultExecutorType\" value=\"SIMPLE\" />\n    <!--设置超时时间：它决定驱动等待数据库响应的秒数,任何正整数-->\n    <setting name=\"defaultStatementTimeout\" value=\"25\"/>\n    <!--设置数据库驱动程序默认返回的条数限制，此参数可以重新设置,任何正整数 -->\n    <setting name=\"defaultFetchSize\" value=\"100\" />\n    <!-- 允许在嵌套语句中使用分页（RowBounds） -->\n    <setting name=\"safeRowBoundsEnabled\" value=\"false\" />\n    <!-- 是否开启自动驼峰命名规则，即从a_example到aExample的映射 -->\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\" />\n    <!-- 本地缓存机制，防止循环引用和加速重复嵌套循环 -->\n    <setting name=\"localCacheScope\" value=\"SESSION\" />\n    <!-- 当没有为参数提供特定JDBC类型时，为空值指定JDBC类型。某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，如NULL/VARCHAR/OTHER -->\n    <setting name=\"jdbcTypeForNull\" value=\"OTHER\" />\n    <!-- 指定触发延迟加载的方法，如equals/clone/hashCode/toString -->\n    <setting name=\"lazyLoadTriggerMethods\" value=\"equals\" />\n</settings>\n\n```\n\n# typeAlianses属性\ntypeAlianses属性就是起别名，是为了在映射文件中更方便的编写输入参数类型和输出结果类型\n系统定义的别名如：int、string等\n自定义别名的三种方法：\n```xml\n<!--配置别名-->\n1. 指定名字\n<typeAliases>\n    <!--对类单独进行别名设置  -->\n    <typeAlias alias=\"user\" type=\"com.thr.pojo.User\"></typeAlias>\n    <typeAlias alias=\"student\" type=\"com.thr.pojo.Student\"></typeAlias>\n</typeAliases>\n2. 自动生成\n<typeAliases>\n    <!-- 对包进行扫描，可以批量进行别名设置，设置规则是：获取类名称，将其第一个字母变为小写 -->\n    <package name=\"com.thr.pojo1\"/>\n    <package name=\"com.thr.pojo2\"/>\n    <package name=\"com.thr.pojo3\"/>\n</typeAliases>\n```\n```java\n\n3.通过注解\npackage com.thr.pojo1;\nimport org.apache.ibatis.type.Alias;\n \n@Alias(\"user1\")\npublic class User {\n    ...\n}\n\n```\n# typeHandlers属性：\n	 typeHandlers叫类型处理器（保留）\n	\n# objectFacotry属性：\n	objectFacotry表示为对象工厂（保留）\n	\n# plugins属性：\n	插件\n\n# environments属性：\nenvironments属性表示的是运行环境，主要的作用是配置数据库的一些信息，我们可以配置多个数据库，但只能选择一个。它里面分为两个可配置的元素：事务管理器(transactionManager)、数据源(DataSource)\n\n# databaseIdProvider属性\n	databaseIdProvider元素主要是为了支持不同厂商的数据库\n\n# mappers属性\n	mapper属性是用来加载映射文件的，也就是加载我们配置的SQL映射文件\nmapper有四种加载方法：\n\n```xml\n1.用文件路径引入\n<mappers>\n    <mapper resource=\"com/thr/mapper/UserMapper.xml\" />\n    <mapper resource=\"com/thr/mapper/StudentMapper.xml\" />\n    <mapper resource=\"com/thr/mapper/TeacherMapper.xml\" />\n</mappers>\n2.使用URL方式引入\n<mappers>\n    <mapper url=\"D:/mappers/UserMapper.xml\" />\n    <mapper url=\"D:/mappers/StudentMapper.xml\" />\n</mappers>\n3.用类注册引入\n<mappers>\n    <mapper class=\"com.thr.mapper.UserMapper\" />\n    <mapper class=\"com.thr.mapper.StudentMapper\" />\n    <mapper class=\"com.thr.mapper.TeacherMapper\" />\n</mappers>\n4.用包名引入（推荐）\n<mappers>\n    <package name=\"com.thr.mapper\"/>\n</mappers>\n```\n\n\n\n\n\n\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:45:03', '2023-01-25 11:45:03');
INSERT INTO `article` VALUES (63, 1, 'Mybatis学习笔记（四）', '# SQL映射文件（xxxMapper.xml）\nSQL映射文件是用来配置SQL映射语句的，根据不同类型的sql语句选择不同的标签，常用的顶级元素有：\n|元素|描述  |\n|--|--|\n| resultMap(重要)| 用于接收查询结果 |\n|sql|可重用语句块|\n|select|映射查找语句|\n|update|映射修改语句|\n|insert|映射插入语句|\n|delete|映射删除语句|\n\n# select主要元素\n|select内部属性|描述  |\n|--|--|\n|id  |  在命名空间中唯一的标识符，可以被用来引用这条语句|\n|  parameterType|  传入这条语句的参数类的完全限定名或别名|\n|resultType  |从这条语句中返回的期望类型的类的完全限定名或别名，如果是集合应该填写集合所包含的类型  |\n| resultMap | 自定义的 resultType |\n| flushCache | 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false |\n| useCache| 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true |\n\n# insert主要元素\n|insert内部属性| 描述 |\n|--|--|\n| id | 在命名空间中唯一的标识符，可以被用来引用这条语句 |\n| parameterType | 传入这条语句的参数类的完全限定名或别名 |\n| useGeneratedKeys | （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false |\n\n## 主键回填\n\n> 在insert元素中，有一个非常重要且常用的属性——**useGeneratedKeys**，它的作用的主键回填，就是将当前插入数据的主键返回。例如在插入语句中，我们没有插入主键 Id 列，因为在mysql数据库中将它设置为自增主键，数据库会自动为其生成对应的主键，所以没必要插入。但是有些时候我们还需要继续使用这个主键，用以关联其它业务，所以十分有必要获取它。比如在新增用户的时候，首先会插入用户的数据，然后插入用户和角色关系表，而插入用户时如果没办法取到用户的主键，那么就没有办法插入用户和角色关系表了，因此这个时候需要拿到对应的主键，以方便关联表的操作。\n\n使用案例留空\n\n# update和delete元素\n\n> 它们和insert元素的属性差不多，执行完后也会返回一个整数，用来表示该SQL语句影响了数据库的记录行数\n\n# sql元素\n\n> sql元素是用来定义可重用的 sql代码片段，这样在字段比较多的时候，以便在其它语句中使用。\n\n```xml\n<!--定义sql代码片段-->\n<sql id=\"userCols\">\n    id,username,age,sex,address\n</sql>\n```\n## sql元素还支持变量的传递\n```xml\n<!--定义sql代码片段-->\n<sql id=\"userCols\">\n    ${alias}.id,${alias}.username,${alias}.age,${alias}.sex,${alias}.address\n</sql>\n<!-- 查询所有用户 -->\n<select id=\"selectAllUser\" resultType=\"com.thr.entity.User\">\n    select <include refid=\"userCols\">\n              <property name=\"alias\" value=\"u\"/>\n           </include>\n    from t_user u\n</select>\n\n```\n# parameterType \n传入类型包括以下几类\n## 1.映射基本数据类型（即八大基本数据类型，比如int，boolean，long等类型）\n\n\n## 2.映射pojo类型(即普通的对象)\n\n## 3. 包装pojo类型(包装pojo类型在Mybatis使用（二）中有使用示例，即内部属性为对象引用，集合等)\n## 4.映射map类型 （还没用到）\n\n# resultType\n\n## 1.映射基本数据类型（即八大基本数据类型，比如int，boolean，long等类型）\n\n## 2.映射pojo类型(即普通的对象)\n\n## 3.映射pojo列表（映射多列数据）\n\n> 映射单个pojo对象和映射pojo列表映射文件中的resultType都配置为pojo类型。区别只是返回单个对象是内部调用selectOne返回pojo对象，返回pojo列表时内部调用selectList方法\n\n```xml\n<!-- 查询所有用户 -->\n<select id=\"selectAllUser\" resultType=\"com.thr.entity.User\">\n    select * from t_user\n</select>\n\n```\n## 4.映射hashmap\n\n# resultMap', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:45:33', '2023-01-25 11:45:33');
INSERT INTO `article` VALUES (64, 1, 'Centos7安装nginx-1.9.9', '# 安装环境\n\n记录安装nginx流程，使用系统centos7\n\n## 安装所需插件\n### 1.安装gcc\ngcc是linux下的编译器\n查看gcc版本\n\n```\ngcc -v\n```\n![gcc版本信息](https://img-blog.csdnimg.cn/20210717165407722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70)\n我的阿里云centos7系统自带gc，如果没有可以使用以下命令下载gcc\n\n```\nyum -y install gcc\n```\n### 2.安装pcre、pcre-devel\nPCRE (Perl Compatible Regular Expressions) 是一个用C语言编写的正则表达式函数库。\n安装命令如下：\n\n```\nyum install -y pcre pcre-devel\n```\n### 3.安装zlib\nzlib是一个压缩库，类似于zip。在linux下看到的*.gz文件，就是用zlib压缩的。\n安装命令：\n\n```\nyum install -y zlib zlib-devel\n```\n### 4.安装openssl\nOpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。\n安装命令：\n\n```\nyum install -y openssl openssl-devel\n```\n## 安装nginx\n我安装的nginx是1.9.9版本的，首先在 /usr/local 路径下面创建nginx文件夹，然后 cd进入该文件夹开始下载nginx安装包\n安装命令：\n\n```\nwget http://nginx.org/download/nginx-1.9.9.tar.gz  \n```\n### 安装完成之后解压到 /usr/local/nginx路径下面\n解压命令\n\n```\ntar -zxvf  nginx-1.9.9.tar.gz\n```\n### 然后进入 /usr/local/nginx/nginx-1.9.9/下\n运行三个命令：\n\n```\n./configure\n \nmake\n \nmake install\n```\n### 之后再进入 /usr/local/nginx/conf/ 目录下面修改nginx的配置文件，主要是修改nginx.conf文件中的端口号信息\n![端口号](https://img-blog.csdnimg.cn/20210717172821625.png)\n将端口号修改为80，不过默认都是80端口，如果需要修改则 按 i 键进入修改，修改完成之后先按 esc 然后 shirf + zz 退出保存。\n\n## 最后就是启动nginx\n进入/usr/local/nginx/sbin 目录下面\n执行：`./nginx` 即可启动nginx，到此为止nginx已经安装完成了\n输入你的ip地址即可访问\n\n如果访问不成功那可能是防火墙的问题\n\n## 启动失败\n执行` ./nginx `提示\nnginx: [alert] could not open error log file: open() \"/usr/local/nginx/logs/error.log\" failed (2: No such file or directory)\n2021/09/16 14:15:15 [emerg] 18033#0: open() \"/usr/local/nginx/logs/access.log\" failed (2: No such file or directory)\n需要在nginx目录下创建logs文件夹\n```\nmkdir logs\nchmod 755 logs\n```\n\n## 解决防火墙问题\n首先要简单确认80端口有没有分给nginx\n执行命令：`netstat -ntlp`\n![80端口](https://img-blog.csdnimg.cn/2021071717374941.png)\n### 第一步\n对防火墙进行配置\n\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\n```\n如果执行第一步提示\n\n![防火墙](https://img-blog.csdnimg.cn/20210717174020153.png)\n则是防火墙未开启\n可以通过systemctl status firewalld确认firewalld状态。dead状态即为防火墙未开启\n\n#### 然后执行systemctl start firewalld开启防火墙，没有提示信息即为防火墙开启成功\n再次执行systemctl status firewalld确认firewalld状态。出现绿色的running则是防火墙开启成功\n接下来就再次执行`firewall-cmd --zone=public --add-port=80/tcp --permanent`开启防火墙\n### 第二布\n重启防火墙就可以了\n\n```\nsystemctl restart firewalld.service\n```\n\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:46:29', '2023-01-25 11:47:57');
INSERT INTO `article` VALUES (65, 1, 'ActiveMQ学习笔记（一）：安装与目录介绍', '# 安装\n\n![安装地址](http://121.4.126.60/files/article/img/2023-02-06_22-02-50_kVnPM_activemq-1.png)\n\n# 目录说明\n```\nbin----存放的是脚本文件\nconf----存放的是基本配置文件\ndata----存放的是日志文件\ndocs----存放的是说明文档\nexamples----存放的是简单的实例\nlib----存放的是activemq所需jar包\nwebapps----用于存放项目的目录\n```\n\n\n\n\n# 启动\n![启动](http://121.4.126.60/files/article/img/2023-02-06_22-03-14_wjqBs_activemq-2.png)\n以管理员权限启动activemq.bat文件,注意cmd窗口关闭之后127.0.0.1:8161将无法访问到\n\n如果想要关闭cmd窗口访问activemq管理页面可以 打开计算机管理，启动activemq服务\n启动步骤：\nwindows + x 打开计算机管理\n![启动服务](http://121.4.126.60/files/article/img/2023-02-06_22-04-08_xppFk_activemq-3.png)\n\n\n# 控制台简介\n```\nQueues：队列方式消息。\nTopics：主题方式消息。\nSubscribers：消息订阅监控查询。\nConnections：查看链接数,分别可以查看xmpp、ssl、stomp、openwire、ws和网络链接。\nNetwork：网络链接数监控。\nScheduled：不太清楚。\nSend：发送消息数据\n```\n\n\n\n\n\n# 配置文件简介\n\n## 登录管理\n登陆管理配置文件在 conf/jetty.xml 文件中\n![登录配置文件](http://121.4.126.60/files/article/img/2023-02-06_22-04-39_hoNym_activemq-4.png)\nroles表示有管理员和用户的角色\nauthenticate表示权限，value为true时需要用户登录\n\n用户登录配置文件在 conf/jetty-realm.properties 文件中\n![用户登录](http://121.4.126.60/files/article/img/2023-02-06_22-05-14_bZSyG_activemq-5.png)\n格式为： 账号， 密码\n\n## 端口号管理\n端口号管理文件 conf/jetty.xml 目录中\n![端口号管理文件](http://121.4.126.60/files/article/img/2023-02-06_22-05-45_RdtdD_activemq-6.png)\n8161即为activemq的端口号\n\n## ActiveMQ连接服务端的方式\n配置文件在 conf/activemq.xml 中\n![连接服务端](http://121.4.126.60/files/article/img/2023-02-06_22-06-07_trLqd_activemq-7.png)\n\n## 持久化配置\n持久化默认方式为 kahaDB ，文件在 conf/activemq.xml 中\n![持久化](http://121.4.126.60/files/article/img/2023-02-06_22-06-26_fphPe_activemq-8.png)\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:18:22', '2023-02-06 22:06:42');
INSERT INTO `article` VALUES (66, 1, 'ActiveMQ学习笔记（二）：点对点方式学习', '# 介绍\n点对点的消息发送方式主要建立在消息（Message），队列（Queue），发送者（Sender），消费者（Receiver）上，Queue存储消息，Sender发送消息，Receiver接收消息，具体流程是Sender Client通过Queue发送message，Receiver Client从Queue中接收消息。消息的发送客户端和消息接收客户端没有时间上的依赖，可以异步进行\n\n# 通过jms编码接口之间的关系\n1. ConnectionFactory创建连接Connection\n2. Connection创建会话Session\n3. 通过Session创建其它的（MessageProducer、MessageConsumer、Destination、TextMessage）\n4. 将生产者和消费者指向Destination\n5. 生产者向目标发送TextMessage消息send()\n6. 消费者设置监听器，监听消息\n![jms](http://121.4.126.60/files/article/img/2023-02-06_22-07-03_avGvG_activemq2-1.png)\n\n\n# 创建项目\n新建maven项目\n![maven](http://121.4.126.60/files/article/img/2023-02-06_22-07-20_HjQtu_activemq2-2.png)\n创建文件目录，先删除之前的src目录\n![src](http://121.4.126.60/files/article/img/2023-02-06_22-07-38_jsHSD_activemq2-3.png)\n创建完成\n![dir](http://121.4.126.60/files/article/img/2023-02-06_22-08-11_RIylR_activemq2-4.png)\n\n\n# 创建生产者\n```\npackage org.emample.jms;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author: lxk\n * @date: 2021/8/1 10:03\n * @description: 生产者\n * @modified By:\n */\npublic class producer {\n    // ActiveMQ的服务器tcp连接方式\n    private static final String url = \"tcp://127.0.0.1:61616\";\n    // 定义队列的名称\n    private static final String queueName = \"queue-test\";\n\n    public static void main(String[] args) throws JMSException {\n        // 1.创建connectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n        // 2.创建connection\n        Connection connection = connectionFactory.createConnection();\n        // 3.启动连接\n        connection.start();\n        // 4.创建session\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        // 5.创建destination\n        Destination destination = session.createQueue(queueName);\n        // 6.创建生产者\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i=0; i<100; i++){\n            TextMessage textMessage = session.createTextMessage(\"发送文本\" + i);\n            producer.send(textMessage);\n            if ((i+1)%10 == 0) {\n                System.out.println(\"已发送\" + (i+1)/10 + \"组\");\n            }\n        }\n        // 7.关闭连接\n        connection.close();\n    }\n}\n\n```\n\n# 创建消费者\n```\npackage org.emample.jms;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author: lxk\n * @date: 2021/8/1 10:05\n * @description: 消费者\n * @modified By:\n */\npublic class consumer {\n\n    // ActiveMQ的服务器tcp连接方式\n    private static final String url = \"tcp://127.0.0.1:61616\";\n    // 定义队列的名称\n    private static final String queueName = \"queue-test\";\n\n    public static void main(String[] args) throws JMSException {\n        // 1.创建connectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n        // 2.创建connection\n        Connection connection = connectionFactory.createConnection();\n        // 3.启动连接\n        connection.start();\n        // 4.创建session\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        // 5.创建destination\n        Destination destination = session.createQueue(queueName);\n        // 6.创建消费者\n        MessageConsumer consumer = session.createConsumer(destination);\n        // 7.创建监听器\n        consumer.setMessageListener(new MessageListener() {\n            @Override\n            public void onMessage(Message message) {\n\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(\"收到消息\" + textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        // 8.关闭连接(监听器是异步的还没有监听到消息的时候，就关闭连接了)\n        // connection.close();\n    }\n}\n```\n# 启动\n注： 启动时会有一个slf4j的报错信息\n![error](http://121.4.126.60/files/article/img/2023-02-06_22-09-15_ndfje_activemq2-5.png)\n在pom文件中添加下图内容就可以解决，具体原因参考大佬的文章：https://blog.csdn.net/weixin_39548940/article/details/100015174\n```\n    <dependency>\n      <groupId>org.slf4j</groupId>\n      <artifactId>slf4j-nop</artifactId>\n      <version>1.7.2</version>\n    </dependency>\n```\n生产者发送信息\n![producer](http://121.4.126.60/files/article/img/2023-02-06_22-08-44_RwdWp_activemq2-6.png)\n然后启动消费者\n![consumer](http://121.4.126.60/files/article/img/2023-02-06_22-09-28_bJVMH_activemq2-7.png)\n\n## 测试两个消费者\n### 启动方式：\n1. 选择消费者\n2. 点击 Edit Configurations...\n![点击](http://121.4.126.60/files/article/img/2023-02-06_22-09-39_nnvsB_activemq2-8.png)\n3.勾选 Allow parallel run 按钮\n![勾选](http://121.4.126.60/files/article/img/2023-02-06_22-10-45_HMHxi_activemq2-9.png)\n\n### 测试\n先启动两个消费者\n![consumer](http://121.4.126.60/files/article/img/2023-02-06_22-10-58_ZnYdi_activemq2-10.png)\n然后启动生产者\n![producer](http://121.4.126.60/files/article/img/2023-02-06_22-11-08_mAsXT_activemq2-11.png)\n观察消费者消息接收情况\n![consumer1](http://121.4.126.60/files/article/img/2023-02-06_22-12-08_HTWVZ_activemq2-12.png)\n![consumer2](http://121.4.126.60/files/article/img/2023-02-06_22-12-17_xBzKy_activemq2-13.png)\n可以看到两个消费者收到的消息并不重复\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:18:47', '2023-02-06 22:13:40');
INSERT INTO `article` VALUES (67, 1, 'ActiveMQ学习笔记（三）：发布订阅模式', '# 发布订阅模式\n发布订阅模式与点对点模式主要区别为，点对点模式支持异步，并且只能有一个接收者，而发布订阅模式可以有很多订阅者，但是不支持异步\n\n\n# 代码实现\n## 发布者\n```\npackage org.emample.jms;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author: lxk\n * @date: 2021/8/1 10:23\n * @description: 发布订阅模式生产者\n * @modified By:\n */\npublic class producerTopic {\n    // ActiveMQ的服务器tcp连接方式\n    private static final String url = \"tcp://127.0.0.1:61616\";\n    // 定义主题的名称\n    private static final String topicName = \"topic-test\";\n\n    public static void main(String[] args) throws JMSException {\n        // 1.创建connectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n        // 2.创建connection\n        Connection connection = connectionFactory.createConnection();\n        // 3.启动连接\n        connection.start();\n        // 4.创建session\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        // 5.创建destination\n        Destination destination = session.createTopic(topicName);\n        // 6.创建生产者\n        MessageProducer producer = session.createProducer(destination);\n\n        for (int i=0; i<100; i++){\n            TextMessage textMessage = session.createTextMessage(\"发送文本\" + i);\n            producer.send(textMessage);\n            if ((i+1)%10 == 0) {\n                System.out.println(\"已发送\" + (i+1)/10 + \"组\");\n            }\n        }\n\n        connection.close();\n    }\n}\n\n```\n\n## 订阅者\n```\npackage org.emample.jms;\n\nimport org.apache.activemq.ActiveMQConnectionFactory;\n\nimport javax.jms.*;\n\n/**\n * @author: lxk\n * @date: 2021/8/1 10:23\n * @description: 发布订阅模式消费者\n * @modified By:\n */\npublic class consumerTopic {\n    public static final String url = \"tcp://127.0.0.1:61616\";\n    public static final String topicName = \"topic-test\";\n\n    public static void main(String[] args) throws JMSException {\n\n        // 1.创建connectionFactory\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\n        // 2.创建connection\n        Connection connection = connectionFactory.createConnection();\n        // 3.启动连接\n        connection.start();\n        // 4.创建session\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n        // 5.创建destination\n        Destination destination = session.createTopic(topicName);\n        // 6.创建消费者\n        MessageConsumer consumer = session.createConsumer(destination);\n        // 7.创建监听器\n        consumer.setMessageListener(new MessageListener() {\n            @Override\n            public void onMessage(Message message) {\n\n                TextMessage textMessage = (TextMessage) message;\n                try {\n                    System.out.println(\"收到消息\" + textMessage.getText());\n                } catch (JMSException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n\n        // 8.关闭连接(监听器是异步的还没有监听到消息的时候，就关闭连接了)\n        // connection.close();\n\n    }\n}\n\n```\n# 启动测试\n先启动两个订阅者\n![consumer](http://121.4.126.60/files/article/img/2023-02-06_22-14-21_UusFo_activemq3-1.png)\n然后启动发布者\n![consumer1](http://121.4.126.60/files/article/img/2023-02-06_22-14-30_DgFEc_activemq3-2.png)\n![consumer2](http://121.4.126.60/files/article/img/2023-02-06_22-14-41_XLVNg_activemq3-3.png)\n可以看到两个订阅者收到了相同的内容\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:19:03', '2023-02-06 22:15:12');
INSERT INTO `article` VALUES (68, 1, '【洛谷】P1586-四方定理--动态规划解法', '# 题目描述\n\n四方定理是众所周知的：任意一个正整数n，可以分解为不超过四个整数的平方和。例如：25=1^2^+2^2^+2^2^+4^2^ ，当然还有其他的分解方案，25=3^2^+4^2^和25=5^2^ 。给定的正整数n，编程统计它能分解的方案总数。注意: 25=3^2^+4^2^和25=4^2^+3^2^ 视为一种方案。\n\n# 输入格式\n\n第一行为正整数t(t≤100)，接下来t行，每行一个正整数n(n≤32768)。\n\n# 输出格式\n对于每个正整数n，输出方案总数。\n\n# 解析\n\n\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,k;\nint arr[181];\nint dp[32769][5];\n\nvoid plan(){\n    dp[0][0] = 1;\n    for(int i=0; i<181; i++){\n        arr[i] = i*i;\n    }\n    for(int i=1;i<181; i++){\n        for(int j=arr[i]; j<32769; j++){\n            for(int num=1; num <=4; num++){\n                dp[j][num] += dp[j-arr[i]][num-1];\n            }\n        }\n    }\n}\n\nint main(){\n    plan();\n    scanf(\"%d\", &n);\n    while(n--){\n        scanf(\"%d\", &k);\n        printf(\"%d\\n\", dp[k][1]+dp[k][2]+dp[k][3]+dp[k][4]);\n    }\n}\n```\n', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:04:46', '2023-02-12 14:04:46');
INSERT INTO `article` VALUES (69, 1, '【洛谷】P2330-繁忙的都市--（并查集、kruskal、prim解法）', '# 题目描述\n城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：\n\n1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。\n\n任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。\n\n# 输入格式\n第一行有两个整数n,m表示城市有n个交叉路口，m条道路。\n\n接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤100000)\n\n# 输出格式\n两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。\n\n# 解析\n首先题目给定所有交叉路口都已经连接起来了，并且道路是双向的，所以是一个无向图，根据要求1可知要把交叉路口看作一个点，要求2说明，尽可能用更少的边（路），要求3：说明这是一个最小生成树，可以使用最小生成树算法Kruskal算法和Prim算法解决，当然并查集也可以使用。\n## 并查集解法\n使用并查集首先要对输入的边（路）进行从小到大的排序，以保证每次选择一条路加入时都是最小的道路，当并查集的check函数判断数组返回1（并查集数组中只有一个区块）则说明所有交叉路口都已经连通，对于输入要俩个数值，一是最小连通的边数，n个点连通最小边数必然是n-1，然后就是使用道路中最大的那条路，对于并查集也就是最后一个加入数组的边。\n\n```c++\n// 并查集解法\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint u,v,c;\nint arr[301];\nstruct node{\n    int x,y,k;\n};\n\nstruct node nd[100000];\n// 并查集find函数，用于判断某一点的上级节点\nint find1(int x){\n    int r=x;\n    while(arr[r]!=r){\n        r=arr[r];\n    }\n    return r;\n}\n// 并查集check函数，用于判断某俩个点是否连通\nint check(){\n    int sum=0;\n    for(int i=1; i<=n; i++){\n        if(arr[i]==i){\n            sum++;\n        }\n    }\n    return sum;\n}\n// 并查集join函数，用于将俩个点连通\nvoid join(int x,int y){\n    int fx = find1(x);\n    int fy = find1(y);\n    if(fx!=fy)\n        arr[fx] = fy;\n}\n// 使用快排\nint cmp(node x,node y){\n    return x.k<y.k;\n}\n\nint main(){\n    scanf(\"%d%d\", &n,&m);\n    for(int i=0; i<=n; i++){\n        arr[i]=i;\n    }\n    for(int i=0; i<m; i++){\n        scanf(\"%d%d%d\", &nd[i].x,&nd[i].y,&nd[i].k);\n    }\n    // 对边进行排序\n    sort(nd, nd+m, cmp);\n    for(int i=0; i<m; i++){\n        join(nd[i].x,nd[i].y);\n        if(check()==1){\n	    // 当加入某个点之后，所有路口都连通输出此时的边长度\n            printf(\"%d %d\\n\", n-1, nd[i].k);\n            break;\n        }\n    }\n}\n```\n## kruskal解法\n每次从所有边中选择一个最短的边，然后判断所选的这条边是否有效，直到选了n-1条边，说实话不清楚kruskal算法和并查集有什么区别\n```c++\n// kruskal算法\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint ans;\nint arr[301];\nstruct node{\n    int x,y,k;\n};\n\nstruct node nd[100000];\n\nint find1(int x) {\n    int r=x;\n    while(arr[r]!=r){\n        r=arr[r];\n    }\n    int a=x,b;\n    while(a != r){\n        b = arr[a];\n        arr[a] = r;\n        a = b;\n    }\n    return r;\n}\n\nint join(int x, int y){\n    int fx = find1(x);\n    int fy = find1(y);\n    if(fx != fy){\n        arr[fy] = fx;\n    }\n}\n\nint cmp(node x,node y){\n    return x.k<y.k;\n}\n\nvoid kruskal(){\n    int a,b;\n    int num=0;\n    ans = 0;\n    sort(nd,nd+m,cmp);\n    for(int i=0; i<m; i++){\n        a = find1(nd[i].x);\n        b = find1(nd[i].y);\n        if(a!=b){\n            ans = max(ans, nd[i].k);\n            num++;\n            join(a,b);\n            if(num == n-1){\n                return;\n            }\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d%d\", &n,&m);\n    for(int i=1; i<=n; i++){\n        arr[i]=i;\n    }\n    for(int i=0; i<m; i++){\n        scanf(\"%d%d%d\", &nd[i].x,&nd[i].y,&nd[i].k);\n    }\n    kruskal();\n    printf(\"%d %d\", n-1, ans);\n}\n```\n## prim解法\n之后写一个文章吧\n```c++\n// prim算法\n#include<iostream>\n#include<fstream>\nusing  namespace std;\n\n#define MAX 301\n#define MAXCOST 0x7fffffff\n\nint n,m;\nint u,v,c;\n\nint graph[MAX][MAX];\nint prim(int n){\n    int lowcost[MAX];\n    int mst[MAX];\n    int m=0,min, minid, sum = 0;\n    for (int i = 2; i <= n; i++){\n        lowcost[i] = graph[1][i];\n        mst[i] = 1;\n    }\n    mst[1] = 0;\n    for (int i = 2; i <= n; i++){\n        min = MAXCOST;\n        minid = 0;\n        for (int j = 2; j <= n; j++){\n            if (lowcost[j] < min && lowcost[j] != 0){\n                min = lowcost[j];\n                minid = j;\n            }\n        }\n        sum += min;\n        m = max(min, m);\n        lowcost[minid] = 0;\n        for (int j = 2; j <= n; j++){\n            if (graph[minid][j] < lowcost[j]){\n                lowcost[j] = graph[minid][j];\n                mst[j] = minid;\n            }\n        }\n    }\n//    return sum;\n    return m;\n}\n\nint main(){\n    scanf(\"%d%d\", &n,&m);\n    for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++){\n            graph[i][j] = MAXCOST;\n        }\n    }\n    for (int k = 1; k <= m; k++){\n        scanf(\"%d%d%d\", &u,&v,&c);\n        graph[u][v] = c;\n        graph[v][u] = c;\n    }\n    printf(\"%d %d\\n\", n-1, prim(n));\n    return 0;\n}\n```', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:05:20', '2023-02-12 14:05:20');
INSERT INTO `article` VALUES (70, 1, '【洛谷】P5429-Fence Planning S--并查集解法', '# 题目描述\n\nFarmer John 的 N 头奶牛，编号为 1…N （ 2≤N≤10^5^ ），拥有一种围绕“哞网”，一些仅在组内互相交流却不与其他组进行交流的奶牛小组，组成的复杂的社交网络。\n\n每头奶牛位于农场的二维地图上的不同位置 (x,y) ，并且我们知道有 M 对奶牛( 1≤M<10^5^ )会相互哞叫。两头相互哞叫的奶牛属于同一哞网。\n\n为了升级他的农场，Farmer John 想要建造一个四边与 x 轴和 y 轴平行的长方形围栏。Farmer John 想要使得至少一个哞网完全被围栏所包围（在长方形边界上的奶牛计为被包围的）。请帮助 Farmer John 求出满足他的要求的围栏的最小可能周长。有可能出现这一围栏宽为 0 或高为 0 的情况。\n\n# 输入格式\n\n输入的第一行包含 N 和 M 。以下 N 行每行包含一头奶牛的 x 坐标和 y 坐标（至多 10^8^ 的非负整数）。以下 M 行每行包含两个整数 a 和 b ，表示奶牛 a 和 b 之间有哞叫关系。每头奶牛都至少存在一个哞叫关系，并且输入中不会出现重复的哞叫关系。\n\n# 输出格式\n输出满足 Farmer John 的要求的围栏的最小周长。\n\n# 解析\n把所有牛都加入并查集，然后判断每一头奶牛的位置，选择出每一个哞叫关系的最小x，y和最大x，y然后计算围栏周长，由于数据量较大，此处的 `struct node fnode[100001];`是选择了牺牲空间换取时间，减少了一次用于寻找该牛所在的哞叫关系的循环\n\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N,M;\nint arr[100001];\n\nstruct node{\n    int flag;\n    int min_x,max_x;\n    int min_y,max_y;\n};\nstruct node fnode[100001];\n\nstruct cow{\n    int x,y;\n};\nstruct cow c[100001];\n\nint find1(int x){\n    int k=x;\n    while(arr[k]!=k){\n        k = arr[k];\n    }\n    int i=x,j;\n    while(i!=j){\n        j = arr[k];\n        arr[i] = j;\n        i = j;\n    }\n    return k;\n}\n\nvoid join(int x, int y){\n    int a = find1(x);\n    int b = find1(y);\n    if(a!=b){\n        arr[b] = a;\n    }\n}\n\nint check(){\n    int sum=0;\n    for(int i=1; i<N; i++){\n        if(arr[i] == i){\n            sum++;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    scanf(\"%d%d\", &N,&M);\n    for(int i=1; i<=N; i++){\n        arr[i] = i;\n        scanf(\"%d%d\", &c[i].x, &c[i].y);\n    }\n    for(int i=1; i<=M; i++){\n        int a,b;\n        scanf(\"%d%d\", &a,&b);\n        join(a,b);\n    }\n    int k=0;\n    bool flag = true;\n    for(int i=1; i<=N; i++) {\n        int p = find1(i);\n        if(fnode[p].flag == 0){\n            fnode[p].flag = p;\n            fnode[p].max_x = fnode[p].min_x = c[i].x;\n            fnode[p].max_y = fnode[p].min_y = c[i].y;\n        } else {\n            fnode[p].max_x = max(c[i].x, fnode[p].max_x);\n            fnode[p].min_x = min(c[i].x, fnode[p].min_x);\n            fnode[p].max_y = max(c[i].y, fnode[p].max_y);\n            fnode[p].min_y = min(c[i].y, fnode[p].min_y);\n        }\n    }\n    int l = 1e9;\n    for(int i=1; i<=N; i++){\n        if(fnode[i].flag!=0){\n            l = min(l, ((fnode[i].max_x - fnode[i].min_x) + (fnode[i].max_y - fnode[i].min_y))*2);\n        }\n    }\n    printf(\"%d\\n\",l);\n}\n```', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:06:03', '2023-02-12 14:06:03');
INSERT INTO `article` VALUES (71, 1, '【公司】11月oj-年会大奖--（约瑟夫环问题-递归解法）', '# 题目描述\n公司绝对按照最近很火的《鱿鱼游戏》一样，再年会上设置一个只有一个人能获得的超级大奖。\n\n游戏规则如下：\n\n参与抽奖的总共有m人，按照1-m号围成一个大圈。\n\n从编号1开始报数，当报到N的时候，将该人淘汰。然后从下一个人开始，继续从1开始报数，到N时被淘汰，直到只剩一人时，获得大奖。\n\n如果你想获得大奖，你得在第一时间 抢占哪个编号才行？\n\n# 输入\n输入只有一行 包含两个整数  分别为m和n\nM代表参赛的总人数 所有人按照1-M编号\nN代表疏导N时被淘汰 \n\n\n1<m<0x7fffffff\n1<n<0x7fffffff\n\n# 输出\n输出最终会获胜的那个编号\n\n# 样例输入\n10 7\n# 样例输出\n9\n# 提示\n输入m可能是一个非常大的数值 这个时候怎么才能快速找到结果\n该题中包含了 可能需要使用复杂度为 O（N）的方法才能在满足时间和内存的条件下，获得结果\n\n如果只能完成50% 可以尝试已在在 m*n 大于  10^10的情况下 程序是否能在5秒内完成\n\n# 解析\n本题是约瑟夫环的一个考察，如果直接保存每一个人的状态按照顺序一步步模拟的话，会因为超时或者内存超限导致失败。\n使用递归需要注意递归有爆栈的风险。\n\n\n。。。\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n    只要 m >> n，算法的时间复杂度就只有 O(1) ，否则就退化为原来的递归算法\n*/\nint f1(int m, int n) {\n    int result = 1;\n    int del;\n    for (int i = 2; i <= m; i++){\n        if (result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n - 1) % i + 1;\n    }\n    return result;\n}\n/**\n    递归式:\n    f(1)=0; 第一个位置永远为0\n    f(i)=f(i)+m%n;\n*/\nint f2(int m, int n){\n    int result = 0;\n    int del;\n    for (int i=2; i<= m; i++){\n        if(result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n/**\n    f3/f4 方法类似\n*/\nint f3(int m, int n){\n    int result = 0;\n    for (int i=2; i<= m; i++){\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n\nint f4(int m, int n){\n    int result = 1;\n    for(int i=2; i<=m; i++){\n        result = (result + n - 1)%i + 1;\n    }\n    return result;\n}\n/**\n    递归暴力解题，输入m = 10w就会爆栈\n*/\nint f5(int m, int n) {\n    if(m == 1) {\n        return 0;\n    } else {\n        return (f3(m-1, n) + n) % m;\n    }\n}\n\n/**\n    数学法，但是效率太低等半天不出结果\n    方法来自  https://cloud.tencent.com/developer/article/1603406\n*/\nint f6(int m, int n) {\n        long D = 1, end = (long)m*(n-1);\n        while (D <= end) {\n            D = (n*D+n-2) / (n-1);\n        }\n        return (long)m*n-D+1;\n    }\n\nint main(){\n    int m,n;\n\n    cin>>m>>n;\n\n    cout<<f1(m,n)<<endl;\n\n    cout<<f2(m,n)<<endl;\n\n    cout<<f3(m,n)<<endl;\n\n    cout<<f4(m,n)<<endl;\n\n    cout<<f5(m,n)<<endl;\n\n    cout<<f6(m,n)<<endl;\n\n}\n\n```\n', NULL, '1', '', 1, 0, 0, '2023-02-12 14:06:26', '2023-02-12 14:06:26');
INSERT INTO `article` VALUES (72, 1, '【公司】题库-最长子串--双指针', '# 题目描述\n产品业务较复杂时，用户程序在实现某一个特定功能时，往往需要与底层模块进行多次交互，然后组合获取的底层结果，最终完成用户功能。\n\n实际上，一个底层模块，由于自身框架设计等原因，导致对外协议接口使用上会存在很多限制，用户程序需要严格根据底层模块的协议来进行交互。\n\n假设存在底层模块，对外提供n种不同交互命令X，编号依次为X1，...，Xn，互不相等，\n\n模块具有如下限制：模块先对接收到的命令进行过滤，提取序列中最长的没有重复的命令序列，如n=7，应用下发命令序列如下：\n\nX1 X2 X3 X1 X5 X4 X2 X5 X7 X6 X1 X3 X2 X3 \n\n\n因此该序列中，最长的没有重复有效命令序列为  X4 X2 X5 X7 X6 X1 X3 ，即最多命令数为 7\n\n简化上述过程，求解出 应用有效命令序列中最多命令数？\n\n# 解析\n题目大概就是求最长不重复子串（子串：原序列中必须连续的一段；子序列：原序列中可以不连续的一段），我这里采用的方法是双指针\n\n```c++\n// 本蒟蒻的解法\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n// 公司题目里面没说n的取值范围\nint arr[10010];\nint main(){\n    scanf(\"%d\",&N);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d\",&arr[i]);\n    }\n    // s表示头指针，e表示尾指针，l记录结果\n    int s=0,l=1;\n    for(int e=0; e<N; e++) {\n        for(int j=s; j<e; j++) {\n            if(arr[j] == arr[e]){\n                s = j+1;\n            }\n        }\n        l = max(l, e-s+1);\n    }\n    printf(\"%d\\n\", l);\n}\n```\n\n```c++\n// 大佬的解法Orz\n# include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint arr[100010], s[100010];\nint N;\n\nint main(){\n    int l=1;\n    scanf(\"%d\", &N);\n    for (int i=0,j=0; i<N; i++){\n        scanf(\"%d\",&arr[i]);\n        ++ s[arr[i]];\n        while (s[arr[i]] > 1) -- s[arr[j++]];\n        l = max(l, i-j+1);\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n```', NULL, '1', '', 1, 0, 0, '2023-02-12 14:06:47', '2023-02-12 14:06:47');
INSERT INTO `article` VALUES (73, 1, '【洛谷】P2820-局域网--并查集解法', '# 题目\n某个局域网内有 n(n≤100) 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 f(i,j) 表示 i,j 之间连接的畅通程度，f(i,j) 值越小表示 i,j 之间连接越通畅，f(i,j) 为 0 表示 i,j 之间无网线连接。\n# 题目描述\n需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的 ∑f(i,j) 最大，请求出这个最大值。\n# 输入格式\n第一行两个正整数 n,k。\n接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。\n# 输出格式\n一个正整数，∑f(i,j) 的最大值。\n\n# 解析\n根据题目可知，局域网是全部联通的，只是有多余线路导致整个网络形成了回路，要求出被除去网线的 ∑f(i,j)，也就是要使用最少的 ∑f(i,j) ，将网络连接起来（把 ∑f(i,j) 看作俩台电脑之间所连网线的长度会好理解一些），所以我可以先把所有电脑网线都拔开，然后使用最短的网线将这些电脑连接起来，剩余的网线长度就是被除去网线长度的最大值。\n\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N,K;\n// 用来记录输入的结构体\nstruct cpt{\n    int x,y,l;\n};\n// 100台电脑最大连接数量也就是4950，下标从1开始，所以4951刚刚好\nstruct cpt c[4951];\n// 使用并查集，用来记录每台电脑的上级，下标从1开始\nint par[101];\n// 并查集find函数，用来寻找某节点的上级\nint find1(int x) {\n    int r=x;\n    // 寻找该节点的上级，直到找到一个节点的上级就是自己退出循环\n    while(par[r]!=r){\n        r=par[r];\n    }\n    // 此处 r 表示传入 x 的最上级\n    int i=x,j;\n    // 压缩路径，将传入 x 的上级设为 r\n    while(i!=j){\n        j=par[r];\n        par[i]=j;\n        i=j;\n    }\n    return r;\n}\n// 并查集join函数，用来将新的节点加入网络\nvoid join(int x, int y) {\n	// 如果上级不一样，修改设置为相同\n    int fx=find1(x), fy=find1(y);\n    if(fx!=fy){\n        par[fx]=fy;\n    }\n}\n// 检查par数组中有几个区块（有几个上级为自己的节点）\nint check(){\n    int sum = 0;\n    for(int i=1; i<=N; i++)\n        if(par[i]==i)\n            sum ++;\n    return sum;\n}\n// 使用快排的cmp，从小到大\nbool cmp(cpt a, cpt b){\n    return a.l<b.l;\n}\n\nint main(){\n	// 用来记录网络中网线的最大长度\n    int length=0;\n    scanf(\"%d%d\",&N,&K);\n    for(int i=1; i<=N; i++)\n        par[i]=i;	// 设置每台电脑的上级都为自己\n    for(int i=1; i<=K; i++){\n        scanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].l);\n        // 记录网线长度\n        length+=c[i].l;\n    }\n    // 将所有节点之间的连接按照网线长度进行排序\n    sort(c+1, c+1+K, cmp);\n    // 对所有网线进行循环\n    for(int i=1; i<=K; i++){\n        int r1 = find1(c[i].x);\n        int r2 = find1(c[i].y);\n        // 如果这两台电脑的上级不同，则使用网线将这俩个区块连接起来\n        // 上级不同说明这两台电脑之间没有连接，此时取出的网线长度还是从小到大排列的\n        // 所以使用这个网线连接可以确保使用的是最短的网线\n        if(r1 != r2){\n            join(c[i].x,c[i].y);\n            // 从总长度中减去使用的网线长度\n            length-=c[i].l;\n        }\n    }\n    // 剩余的长度即为最大长度\n    printf(\"%d\",length);\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:07:06', '2023-02-12 14:07:06');
INSERT INTO `article` VALUES (74, 1, '【最短路】floyd', '# 解析\n有n个点，查找从i到j的最短路线，从n个点中任选一个点k，然后从i到k，从k到j和从i到j判断那个距离更短，如果经过k的距离更短就更新i到j的距离，简简单单的一个三层for循环，这个算法知道就行了，一般用不到，即使能用到也会有更好的解法\n# 代码\n\n```c++\nint n;\nint mapp[301][301]\n\nvoid floyd(){\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=n; j++){\n            for(int k=1; k<=n; k++){\n                if(e[i][j]>e[i][k]+e[k][j]){\n                    e[i][j] = e[[i][k]+e[k][j];\n                }\n            }\n        }\n    }\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:07:30', '2023-02-12 14:07:30');
INSERT INTO `article` VALUES (75, 1, '【洛谷】P2055-匈牙利算法', '# 题目描述\n学校放假了……有些同学回家了，而有些同学则有以前的好朋友来探访，那么住宿就是一个问题。\n\n比如 A 和 B 都是学校的学生，A 要回家，而 C 来看B，C 与 A 不认识。我们假设每个人只能睡和自己直接认识的人的床。那么一个解决方案就是 B 睡 A 的床而 C 睡 B 的床。而实际情况可能非常复杂，有的人可能认识好多在校学生，在校学生之间也不一定都互相认识。\n\n我们已知一共有 n 个人，并且知道其中每个人是不是本校学生，也知道每个本校学生是否回家。问是否存在一个方案使得所有不回家的本校学生和来看他们的其他人都有地方住。\n\n# 输入格式\n第一行一个数 T 表示数据组数。接下来 T 组数据，每组数据第一行一个数 n 表示涉及到的总人数。\n\n接下来一行 n 个数，第 i 个数表示第 i 个人是否是在校学生 (0 表示不是，1 表示是)。再接下来一行 n 个数，第 i 个数表示第 i 个人是否回家 (0 表示不回家，1 表示回家，注意如果第 i 个人不是在校学生，那么这个位置上的数是一个随机的数，你应该在读入以后忽略它)。\n\n接下来 n 行每行 n 个数，第 i 行第 j 个数表示 i 和 j 是否认识 (1 表示认识，0 表示不认识，第 i 行 i 个的值为 0，但是显然自己还是可以睡自己的床)，认识的关系是相互的。\n# 输出格式\n对于每组数据，如果存在一个方案则输出 ^_^，否则输出T_T。（注意输出的都是半角字符，即三个符号的 ASCII 码分别为 94,84,95）\n\n# 解析\n`匈牙利算法应用于二分图（即可以分为两大部分，且个部分内不连接的图）匹配的问题，它的时间复杂度为O（nm）。它的基本原理是增广路。`\n又题可知,本题是将所有留在学校的人和床位匹配,所以可以使用匈牙利算法进行解决\n\n## 匈牙利算法简介\n```c++\nint M, N;            // M, N分别表示左、右侧集合的元素数量\nint arr[MAXM][MAXN]; // 邻接矩阵存图,存放左右关系\nint p[MAXN];         // 记录当前右侧元素所对应的左侧元素\nbool vis[MAXN];      // 记录右侧元素是否已被访问过\nbool dfs(int k){\n	// 对右侧 N 个元素进行遍历\n    for (int i = 1; i <= N; i++)\n	    // 有边且未访问\n        if (arr[k][i] && !vis[k]){\n			// 记录状态为访问过\n            vis[i] = true;\n            // 如果右侧暂无匹配，或者原来匹配的左侧元素可以找到新的匹配\n            if (p[i] == 0 || dfs(p[i])){\n				// 当前左侧元素成为当前右侧元素的新匹配\n                p[i] = k;\n                return true;\n            }\n        }\n    // 循环结束，仍未找到匹配，返回匹配失败\n    return false;\n}\nint hungary(){\n    int cnt = 0;\n    // 依次取左侧 M 个元素\n    for (int i = 1; i <= M; i++){\n	    // 重置vis数组\n        memset(vis, 0, sizeof(vis));\n        if (dfs(i))\n            cnt++;\n    }\n    return cnt;\n}\n```\n\n## 本题解法\n```c++\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\nconst int MAX_N = 51;\n\nint t;\nint n;\nint arr[MAX_N][MAX_N];\nint stu[MAX_N],hom[MAX_N];\n\nint bed[MAX_N];\nint vis[MAX_N];\n\nbool dfs(int x){\n    for(int i=1; i<=n; i++)\n    	// stu[i] 因为只有在校学生才会有床位\n    	// arr[x][i] x 和 i 有认识关系\n    	// vis[i] 该床位未访问 0未访问 1已访问\n        if(stu[i] && arr[x][i] && !vis[i]){\n            vis[i] = 1;\n            // 床位i没有被占用 或者占用该床位的人可以找到新的床位\n            if(bed[i] == 0 || dfs(bed[i])){\n                bed[i] = x;\n                return true;\n            }\n        }\n    return false;\n}\n\nbool hungary(){\n    memset(bed,0,sizeof(bed));\n    for(int i=1; i<=n; i++){\n        memset(vis,0,sizeof(vis));\n        if(!stu[i] || !hom[i]){\n            if(!dfs(i)){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    scanf(\"%d\",&t);\n    while(t--){\n        scanf(\"%d\",&n);\n        for(int i=1;i<=n;i++)\n            scanf(\"%d\",&stu[i]);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d\", &hom[i]);\n            if(!stu[i]){\n                hom[i]=1;\n            }\n        }\n        memset(arr,0,sizeof(arr));\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                scanf(\"%d\",&arr[i][j]);\n            }\n            if(stu[i]){\n                arr[i][i]=1;\n            }\n        }\n\n        if(hungary()){\n            printf(\"^_^\\n\");\n        } else {\n            printf(\"T_T\\n\");\n        }\n    }\n    return 0;\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-02-12 14:07:52', '2023-02-12 14:07:52');
INSERT INTO `article` VALUES (76, 1, '【二分图】判断二分图', '```\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n\nbool flag=true;\n// 边相连关系矩阵\nbool G[MAX_N+1][MAX_N+1];\nint n,m,col[MAX_N+1];\n// bfs循环队列\nqueue<int> Q;\nvoid bfs(int x){\n    // 初始节点入队，染色\n    Q.push(x);\n    col[x]=0;\n    while(!Q.empty()){\n        int p=Q.front();\n        Q.pop();\n        for(int i=1;i<=n;i++){\n            // 枚举和点p相连结点\n            if(G[p][i]){\n                // 相同颜色则不为二分图\n                if(col[i]==col[p])\n                    flag=false;\n                else if(col[i]==-1){\n                    // 染相反的颜色\n                    col[i]=!col[p];\n                    // 入队等待\n                    Q.push(i);\n                }\n            }\n        }\n    }\n}\n\nvoid dfs(int p){\n    for(int i=1;i<=n;i++){\n        // 枚举和点p相连结点\n        if(G[p][i]){\n            // 相同颜色则不为二分图\n            if(col[i]==col[p])\n                flag=false;\n            else if(col[i]==-1){\n                // 染相反的颜色\n                col[i]=!col[p];\n                dfs(i);\n            }\n        }\n    }\n}\n\nint main(){\n    // n个点 m条边\n    scanf(\"%d%d\", &n,&m);\n    for(int i=1; i<=m; i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        G[u][v]=G[v][u]=true;\n    }\n    // 初始颜色都为-1\n    memset(col,-1,sizeof col);\n    for(int i=1; i<=n; i++){\n        if(col[i]==-1) {\n            col[i] = 0;\n            dfs(i);\n//            bfs(i);\n        }\n    }\n    if(flag) {\n        printf(\"true\");\n    } else {\n        printf(\"false\");\n    }\n}\n```', NULL, '1', '', 1, 0, 0, '2023-02-12 14:08:30', '2023-02-12 14:08:35');
INSERT INTO `article` VALUES (77, 1, '【年终总结】2021年年终总结', '## 回首过去，2021年总结\n今年是从学习走向工作的第一年，我也算是第二次走入社会了，回想起上次还是在初中因为不好好学习，被家里弄到广州饭店打工半年的经历，不知现在应该是有些庆幸呢还是怎样的感觉，总的来说现在能完成学业，在一个差不多的大学毕业还算是可以吧，废话少说，先整理一下2021年的事情，首先在东方国信实习完成了，实习期间也没要我做太多的业务相关事情，就一打杂的，录视频，整理文档，sql啥事都干，就是开发工作没几个，剩下的时间就是自己一个人上网看看资料做一些，笔记，现在不打算继续使用印象笔记了，有时间把当时的笔记整理一下放在博客中，当然我现在博客没有app端，所以这个是2022年的首要任务。实习结束就回家写完了毕业设计，顺便把驾照考完了，然后就是顺其自然的去学校答辩，虽然答辩中老师卡了几次，还好最后是通过了，现在大华的这份工作是答辩之后找的，因为当时实习也没太多时间去准备面试找工作，到最后毕业了才开始找，都没有准备，面试了一周，还好第一个面试的大华就通过了，为了别毕业没工作，回家啃老，我就没有等其它面试直接同意了大华的offer，来之前我一直以为大华就是一个小公司，组个一层写字楼办公，没想到来了之后才发现比我之前的东方国信园区还要大很多，算是个意外的惊喜，来了半年都是大小周，工作日晚上也加班，但还好晚上可以自己学习，日常福利也不错，所以决定在大华再留一年，也就是2022年暂时不考虑换工作的事情，专心学习技术，总结2021年主要的事情也就几个：\n1. 实习顺利完成\n2. 大学顺利毕业，驾照顺利拿下\n3. 博客系统做好，现在投入使用，功能算是稳定，但感觉不太人性化\n\n## 展望未来，2022年计划\n2022年应该会有很多事情把，我是这么想的，在公司工作半年多了，现在大部分功能需求我也可以独立完成，就是在老的项目中进行的开发还需要公司前辈的帮助，尤其的那个admin的项目，用到的struct架构完全不懂啊，没有文档，接口也不想spring那样清楚，不过也接了几个admin的任务修改，现在花点时间还勉强能够完成，希望以后的任务让我多做一点新的项目，争取在2022年能够成为我们项目组开发的中坚力量，不想现在这样一直当个菜鸡。\n2022年主要计划：\n1. 首先就是app的开发，没有app好难受啊，但是现在也没开发过app，所以目前预计6月左右做出我的第一版app\n2. 再就是博客前后端的优化和其它临时想到的小功能的开发，维护好我的服务器，等服务器到期之后换一个2核4g的，现在太慢了\n3. 还有日记要坚持下去，从刚开始工作到今天已经写了168篇日记，要继续努力\n4. 要是还有时间可以考虑小程序版的博客\n5. 最后就是等2022年结束之后回顾我现在的任务完成情况\n\n## 其它事情\n本来想着把这一年看过的动漫、小说、做过的算法题都统计一下，但是发现我完全没有记录，因为平时习惯删除数据，加上换了手机所以就2021年的各项数据都没有，所以现在就挂一个gitee开发情况把，等明年一定要把洛谷、b站、看过的书、动漫等数据都统计好\n![2022-01-04-zongjie2021-1.png](http://121.4.126.60/files/article/img/2023-02-12_14-11-31_xQxtu_2022-01-04-zongjie2021-1.png)\n看着我的gitee提交记录就想到了一张图片：\n![2022-01-04-zongjie2021-2.jpg](http://121.4.126.60/files/article/img/2023-02-12_14-11-59_BKVEz_2022-01-04-zongjie2021-2.jpg)\n要是我的gitee像这片叶子一样绿该多好啊，不过也不能为了数据就刷gitee的提交记录，还是要实事求是，保证每次gitee的提交都有新的功能。\n2021年总结就这些吧。\nps：一定要做博客文章草稿缓存的功能，说多了都是泪啊，这么多字已经是第二次写了\n\n01-05 数据补充：\n虽然去年没有记录大部分事情，但是稍微的一点数据还是有的：\n首先是b站数据（不看我都知道是在b站打卡的一年，因为平时听音乐，看动漫都在b站）：\n![2022-01-05-zongjie2021-3.png](http://121.4.126.60/files/article/img/2023-02-12_14-12-31_zMfKy_2022-01-05-zongjie2021-3.png)\n还有跑步记录，毕业之前跑步的数据因为换账号没了，工作之后也就10月份之前还跑步，之后膝盖疼，在之后天气变冷了没去跑步：\n这个是跑步记录，五公里跑道27分钟多点也算是我当时的最好记录了，今年天气暖和之后要接着跑，试试能不能突破现在这个记录\n![2022-01-05-zongjie2021-4.png](http://121.4.126.60/files/article/img/2023-02-12_14-12-57_kJkQr_2022-01-05-zongjie2021-4.png)\n总跑步里程，每天五公里左右\n![2022-01-05-zongjie2021-5.png](http://121.4.126.60/files/article/img/2023-02-12_14-13-27_graKa_2022-01-05-zongjie2021-5.png)\n还有一个数据那自然是游戏了\nEPIC：\n![2022-01-05-zongjie2021-6.png](http://121.4.126.60/files/article/img/2023-02-12_14-13-50_Zasrl_2022-01-05-zongjie2021-6.png)\n白嫖了那么多游戏，但是也都不玩\nsteam：\n![2022-01-05-zongjie2021-7.png](http://121.4.126.60/files/article/img/2023-02-12_14-14-13_XmVOy_2022-01-05-zongjie2021-7.png)\nsteam玩的比较多，第一个浮岛物语是全成就通关了，我相信我再也不会打开这个游戏了，玩吐了，为了达成全成就看个动漫也要挂机，霓虹深渊和浮岛物语是今年11月才买的，刚买就玩的次数比较多吧，然后还有缺氧开了一个miniBase的图，算是完美通关了吧，就是最后没有截图留念一下，现在应该备份也没了。\n今天先就补充这些。', NULL, '18', '', 1, 0, 0, '2023-02-12 14:11:33', '2023-02-12 14:14:29');
INSERT INTO `article` VALUES (78, 1, '【年终总结】2022年年终总结', '总结之前先看一下去年的计划，做到的和没做到的，整理总结不足和优势，制定2023年的新计划\n## 回首过去，2022年总结\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2022年是正式工作的一年，虽然2021年开始参加的工作，但是21年前半年除了在东方国信实习考驾照之类的事情就没其它重要的事情了，后半年虽然是入职了但是也没有什么太重要的任务给我，所以22年才是一整年工作，正式工作的第一年。按照惯例，先记录22年做了哪些事情，22年年初第一次拿到了年终奖，虽然不是很多至少我还是很满意的，按照时间顺序记录重要的事情我好像想不到几个，所以就想到什么写什么吧，首先是博客这个，博客作为我代码学习的见证者，每次学到什么新技术都塞到博客里面，除了博客做的功能可以做我的笔记，在编写博客的过程也放我学习到了很多新技术，现在我使用的这个博客是从22年六月份开始开发的，到现在也八个月了，不管做的怎么样，至少是可以支持我在线写文章了，先说博客后端架构：整体我是用的微服务架构，使用的nacos注册中心、配置中心，后端整体分为五个模块，首先是网关使用的spring cloud gateway，所有接口都是通过网关转发到对应模块，之后又分为四个模块，分别是鉴权模块，用户模块，文件模块和内容模块；鉴权模块就是用来判断用户的权限，给对应用户发放token，用户模块负责博客用户和角色的管理，给用户授权相关功能，文件模块现在只能上传图片，压缩吧，文件应该也行，但是我没放开这个上传权限，可能上传不成功吧，没有测试过，还有一个内容模块，这个就是处理文章、日记、文档等关于博客内容的服务模块，之后还写了前端，但是我前端实在是太差了，弄得页面丑的一比，当时开发的时候想的就是能用就行，现在确实是能用了。除了博客的前后端还学习了shell以及服务器相关的知识，这个也是为了博客部署而服务，主要是用来一键部署博客，之前给服务器重装系统之后要我手动一个一个安装软件，还得看着别出错，非常麻烦，现在博客只要出啥问题我直接一键部署，只要把文件和数据库备份好就行，这个也是22年的重要成绩吧，这样想来22年确实学习的所有内容都与博客有关，还有一个mq队列，这个暂时还没加入博客功能，redis也没有对接口优化，所以23年的任务也很多，除了博客还有很多其它事情，例如22年大华搬到了1399我也跟着公司到了新工位，以前只在电视上看到的一人一个格子的工位我竟然也可以使用；前半年和保持算法的学习，但是后来开发新博客都没时间了，暂时也不打算继续，还是做一些实用的功能我更喜欢一些，还有很多很多事情现在就不一一记录了，每天都在有写日记，先看看22年年初制定的计划，嘲讽下过去一年的我自己。\n1. 首先就是app的开发，没有app好难受啊，但是现在也没开发过app，所以目前预计6月左右做出我的第一版app\n**不好意思，这个没做到，app我是有一个，但是仅限于demo，去年的我还是太狂妄了，没有摸清app的水，就盲目制定计划，今年也不一定要做，现在要着重全栈开发，优先学习前后端，开发app算是业余爱好**\n2. 再就是博客前后端的优化和其它临时想到的小功能的开发，维护好我的服务器，等服务器到期之后换一个2核4g的，现在太慢了\n**这里说的博客是旧版的博客，spring boot + shiro的框架，现在已经不用了，时代变了，现在我要学习微服务**\n3. 还有日记要坚持下去，从刚开始工作到今天已经写了168篇日记，要继续努力\n**日记一直再坚持，日记已经上传新版微服务博客了**\n4. 要是还有时间可以考虑小程序版的博客\n**这个可以考虑，大前端嘛，也不一定**\n5. 最后就是等2022年结束之后回顾我现在的任务完成情况\n**在写了，推迟了一个半月的年终总结**\n\n## 展望未来，2023年计划\n今天就继续大华工作一年吧，认真工作做好工作相关的事情抓紧学习，上网多了，看到别人的博客都做得那么好，既是羡慕，又是惭愧，看网上视频学习vue也没啥长进，都是看一半懒得看了，我觉得我还是适合敲代码练习，从github上找大佬的项目，然后自己慢慢研究，不会的就去百度，这样的学习方式更适合我，也可以自己做到对症下药，看视频找不到适合我的项目，最近找到一个大佬的博客，后端技术栈和我的不一样，但是我们前端都是vite+vue，还有饿了么ui，我觉得可以从这个大佬的项目中学习一些网站动画，让我自己的博客也变得好看一些，好的功能也抄一下，以前上学的时候总觉得要去抄还不如不写，但是现在我觉得抄也是一种不错的学习方式，毕竟让我自己去摸索确实是有点难度的，最后总结写今年计划吧。\n1. web端博客做的稍微好看一点，就算是抄大佬的博客都行\n2. 开始记录笔记和博客文章，也不要求每个月几篇，尽可能的把需要记录的都写下来，也是为了学习，要求质量没必要要求数量，自行车都造好了，不用有些浪费\n3. 前端学习nuxt，vue的博客加载有点慢，框架有自己的原因，部署的服务器也不是很好的服务器，优化也不到位\n4. 后端学习下三方登陆吧，还有其它用到的一些技术，现在还是注重使用，我这直接写学习springboot原理，看源码啥的不现实，现在我还是太菜了，一步一步慢慢来\n5. 继续坚持日记，还有今年要坚持锻炼，不是出去跑步，不过偶尔跑步也行，每天要在睡觉前做俯卧撑，今年从最开始30个俯卧撑30个深蹲到现在已经提到了50个俯卧撑30个深蹲，然后就是坚持每天早睡，一般情况都在十一点前熄灯，十一点半前睡觉，周末也要拒绝熬夜，至少今年到现在还是好好坚持\n6. 最后那当然的23年年底回来再看看现在幼稚的我，想到了点扎心的事，就不写下来了，不知道年底会不会回忆起来，再扎心一次\n\n- 2023年2月12日15点14分，这次先写这么多，数据总结我先想想也找些图片\n\n## 其它事情\n\n\n\n', NULL, '18', '', 1, 0, 0, '2023-02-12 14:15:41', '2023-02-12 15:15:31');

-- ----------------------------
-- Table structure for article_label
-- ----------------------------
DROP TABLE IF EXISTS `article_label`;
CREATE TABLE `article_label`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL,
  `label_type` int(10) UNSIGNED NULL DEFAULT NULL COMMENT '标签类型id',
  `label_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  `article_num` tinyint(4) NULL DEFAULT NULL COMMENT '文章数量',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '标签创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '标签最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_label
-- ----------------------------
INSERT INTO `article_label` VALUES (1, 1, 1, '算法', 2, '2023-04-17 23:18:17', '2023-04-17 23:18:17');
INSERT INTO `article_label` VALUES (2, 1, 1, '多线程', 2, '2023-04-17 23:18:17', '2023-04-17 23:18:17');
INSERT INTO `article_label` VALUES (3, 1, 1, 'mybatis', 1, '2023-04-17 23:18:17', '2023-04-17 23:18:17');
INSERT INTO `article_label` VALUES (4, 1, 2, 'dfs', 1, '2023-04-17 23:18:17', '2023-04-17 23:18:17');

-- ----------------------------
-- Table structure for article_label_type
-- ----------------------------
DROP TABLE IF EXISTS `article_label_type`;
CREATE TABLE `article_label_type`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL,
  `type_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标签分类名称',
  `label_num` tinyint(4) NULL DEFAULT NULL COMMENT '标签数量',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '标签分类创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '标签分类最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_label_type
-- ----------------------------
INSERT INTO `article_label_type` VALUES (1, 1, 'java', 3, '2023-04-17 23:17:04', '2023-04-17 23:17:04');
INSERT INTO `article_label_type` VALUES (2, 1, '算法', 1, '2023-04-17 23:17:04', '2023-04-17 23:17:04');

-- ----------------------------
-- Table structure for article_type
-- ----------------------------
DROP TABLE IF EXISTS `article_type`;
CREATE TABLE `article_type`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `parent_id` int(11) UNSIGNED NULL DEFAULT NULL COMMENT '文章分类上级 根分级为0',
  `type_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  `create_user` int(11) NULL DEFAULT NULL COMMENT '创建用户',
  `num` int(11) NULL DEFAULT NULL COMMENT '文章数量',
  `node` tinyint(2) NULL DEFAULT NULL COMMENT '是否有子节点 （0：无 1：有）',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 42 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_type
-- ----------------------------
INSERT INTO `article_type` VALUES (1, 0, '算法', 1, 2, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:24');
INSERT INTO `article_type` VALUES (2, 1, '洛谷', 1, 2, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:24');
INSERT INTO `article_type` VALUES (3, 2, '排序', 1, 1, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (4, 2, '搜索', 1, 0, 0, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (5, 0, 'MySQL', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (6, 0, 'Spring', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (7, 6, '注解', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (8, 0, '安装教程', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (9, 8, 'Centos', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (10, 0, 'Mybatis', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (11, 10, '学习', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (12, 10, '使用', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (13, 0, 'JAVA', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (14, 13, 'JVM', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (15, 0, 'ActiveMQ', 1, 0, 0, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (16, 15, '学习', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (17, 15, '使用', 1, 0, 1, '2023-04-17 23:15:20', '2023-04-17 23:15:20');
INSERT INTO `article_type` VALUES (18, 0, '年终总结', 1, 0, 0, '2023-04-17 23:15:20', '2023-04-17 23:15:20');

-- ----------------------------
-- Table structure for blog_diary
-- ----------------------------
DROP TABLE IF EXISTS `blog_diary`;
CREATE TABLE `blog_diary`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(10) NULL DEFAULT NULL COMMENT '创建用户',
  `diary_md` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '日记md格式',
  `diary_date` date NULL DEFAULT NULL COMMENT '日记日期',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1104 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_diary
-- ----------------------------

-- ----------------------------
-- Table structure for doc_catalog
-- ----------------------------
DROP TABLE IF EXISTS `doc_catalog`;
CREATE TABLE `doc_catalog`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建者id',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '父目录id',
  `doc_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文档名字',
  `doc_level` tinyint(4) NULL DEFAULT NULL COMMENT '目录层级(0-4) 0：文档分类 1：文档  2、3：文档章节&文档内容 4：文档内容',
  `doc_type` tinyint(4) NULL DEFAULT NULL COMMENT '文档分类 (0,1) 0：目录 1：内容',
  `sort` smallint(6) NULL DEFAULT NULL COMMENT '排序id',
  `img_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '封面图片url (封面层级一定是1)',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 25 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of doc_catalog
-- ----------------------------
INSERT INTO `doc_catalog` VALUES (1, 1, 0, '日常记录', 0, 0, 1, NULL, '2023-01-23 09:47:04', '2023-01-23 09:47:24');
INSERT INTO `doc_catalog` VALUES (2, 1, 0, '游戏记录', 0, 0, 1, NULL, '2023-01-23 09:47:04', '2023-01-23 09:47:24');
INSERT INTO `doc_catalog` VALUES (3, 1, 1, '年终总结', 1, 0, 1, NULL, '2023-02-06 22:17:09', '2023-02-06 22:17:09');
INSERT INTO `doc_catalog` VALUES (4, 1, 1, '读书笔记', 1, 0, 1, NULL, '2023-02-19 17:38:00', '2023-02-19 17:38:00');
INSERT INTO `doc_catalog` VALUES (5, 1, 4, '文学小说', 2, 0, 1, NULL, '2023-05-21 16:49:53', '2023-05-21 16:49:56');
INSERT INTO `doc_catalog` VALUES (6, 1, 5, '《献给阿尔吉侬的花束》', 3, 1, 1, NULL, '2023-02-19 17:39:22', '2023-02-19 17:39:22');

-- ----------------------------
-- Table structure for doc_content
-- ----------------------------
DROP TABLE IF EXISTS `doc_content`;
CREATE TABLE `doc_content`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建者id',
  `catalog_id` int(11) NULL DEFAULT NULL COMMENT '目录id',
  `doc_content_md` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'md格式文档',
  `browse_count` int(11) NULL DEFAULT NULL COMMENT '文档浏览次数',
  `like_count` int(11) NULL DEFAULT NULL COMMENT '文档点赞次数',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '文档创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '文档最近修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of doc_content
-- ----------------------------
INSERT INTO `doc_content` VALUES (1, 1, 6, '![献给阿尔吉侬的花束-封面.jpg](http://121.4.126.60/files/doc/img/2023-02-19_17-40-54_TZhkQ_xgaejndhs.jpg)\r\n书名： 《献给阿尔吉侬的花束》\r\n时间： 2023-01.13 ~~ 2023-02.13\r\n整体评价： ★★★★☆\r\n评价理由： 故事非常精彩，讲述了一个傻子从开始接受变聪明的手术到变得非常聪明最后又因为手术的原因导致智力水平又变回最开始的样子，全书以主角第一人称的笔记来记录的，有点类似《火星救援》，看书的时候稍微有点代入感，但是也因为这个原因经常就没看记录日期，需要倒回去重新看，之所以给四星是因为看到后面已经预料到结局了，读之后的剧情就好像是在看主角给自己定制棺材一样，有点凄凉。\r\n个人感想： 想半天没啥感想，但是因为这个是第一期读书笔记稍微写点吧。感觉这本书写的主要剧情也就是周围人的态度，与主角个人的心里成长和智慧上的成长。在心理方面是对纪尼安小姐的感情吧，智慧方面是从儿童智慧开始，然后不断成长，慢慢超越周围人的认知，以至于对所有人的评价包括对他做手术的教授也觉得是如此的幼稚。阿尔吉侬是和主角接受同一个手术的老鼠，但是阿尔吉侬接受手术的时间要早于主角，所以书中描写这只老鼠的变化的时候差不多也就宣判了主角的命运，书名叫这个我猜大概是表达主角内心的孤独吧，在手术之前虽然没有朋友，但周围的人至少都欢迎他，等变聪明之后发现原来当时的受欢迎也只不过是被人捉弄罢了，最后又恢复初始智商时认为这不过是一场梦，那只不过是他的另一个人格，就是不知道最后结局会不会和阿尔吉侬一样。最后总结虽然是本好书，但我不是很喜欢，也可能是我人生阅历还不够。', 0, 0, '2023-02-19 17:39:22', '2023-02-19 18:22:27');

SET FOREIGN_KEY_CHECKS = 1;
