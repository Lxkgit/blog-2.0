/*
 Navicat Premium Data Transfer

 Source Server         : 121.4.126.60
 Source Server Type    : MySQL
 Source Server Version : 50737
 Source Host           : 121.4.126.60:3306
 Source Schema         : blog_content

 Target Server Type    : MySQL
 Target Server Version : 50737
 File Encoding         : 65001

 Date: 27/01/2023 17:48:24
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(10) UNSIGNED NULL DEFAULT NULL COMMENT '文章发布用户',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标题',
  `content_md` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'markdown格式文章内容',
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'html格式文章内容',
  `article_type` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章类型（分类由大到小使用 , 隔开）',
  `article_label` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标签（标签顺序不分先后 使用 , 隔开）',
  `article_status` tinyint(4) NULL DEFAULT NULL COMMENT '文章状态（2：置顶 1：发布 0：草稿）',
  `browse_count` int(11) NULL DEFAULT NULL COMMENT '文章浏览次数',
  `like_count` int(11) NULL DEFAULT NULL COMMENT '文章点赞次数',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '文章创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '文章最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 68 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (43, 1, '【洛谷】P1873-EKO  砍树-二分', '## 题目描述\n\n伐木工人 Mirko 需要砍 M 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。\n\nMirko 的伐木机工作流程如下：Mirko 设置一个高度参数 H（米），伐木机升起一个巨大的锯片到高度 H，并锯掉所有树比 H 高的部分（当然，树木不高于 H 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 20,15,10 和 17，Mirko 把锯片升到 15 米的高度，切割后树木剩下的高度将是 15,15,10 和 15，而 Mirko 将从第 1 棵树得到 5 米，从第 4 棵树得到 2 米，共得到 7 米木材。\n\nMirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 H，使得他能得到的木材至少为 M 米。换句话说，如果再升高 1 米，他将得不到 M 米木材。\n\n## 输入格式\n\n第 1 行 2 个整数 N 和 M，N 表示树木的数量，M 表示需要的木材总长度。\n\n第 2 行 N 个整数表示每棵树的高度。\n\n## 输出格式\n1 个整数，表示锯片的最高高度。\n\n## 输入输出样例\n### 输入\n```\n4 7\n20 15 10 17\n```\n### 输出\n```\n15\n```\n## 说明/提示\n对于 100% 的测试数据，1≤N≤10^6^, 1≤M≤2×10^9^，树的高度 <10^9^，所有树的高度总和 >M。\n## 解析\n这道题的标签是二分，不过我的解法没有使用二分，算是以数目高度排序之后的暴力枚举解法。\n由题意可知要求锯片高度尽可能高，所以应该从最高的树木开始，然后降低锯片高度直到找到刚好能够满足题目要求的木材数量然后输出答案，但是这个会有个问题，就是树木的最大高度是10^9^,依次降低高度必然超时，所以需要用到排序，当树木高度有序时每次将锯片的高度降为前一棵树的高度，此次下降锯片砍树总长度 = （前一棵树高度 - 当前树高度）*  被砍树木数， 总砍树长度 = 此次下降锯片砍树总长度 + 之前砍树的总长度，  直到总砍树长度比目标长度大时需要抬高锯片，抬高锯片的高度 = 多余的砍树高度 / 被砍树木数。\n\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nint arr[1000000];\nint len,num;\n\nint main() {\n    cin>>n>>m;\n    for(int i=0; i<n; i++){\n        cin>>arr[i];\n    }\n    sort(arr,arr+n);\n    len = 0;\n    num = n-1;\n    while(len<m){\n        len += (arr[num]-arr[num-1]) * (n-num);\n        num--;\n    }\n    cout<<arr[num] + (len-m) / (n-num-1)<<endl;\n	return 0;\n}\n```\n', NULL, '1,2', '4', 1, 0, 0, '2023-01-23 10:30:35', '2023-01-23 10:49:04');
INSERT INTO `article` VALUES (44, 1, '【洛谷】P1443-马的遍历-bfs', '## 题目描述\n有一个 n×m 的棋盘，在某个点 (x,y) 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。\n\n## 输入格式\n输入只有一行四个整数，分别为 n,m,x,y。\n\n## 输出格式\n一个 n×m 的矩阵，代表马到达某个点最少要走几步（左对齐，宽 5 格，不能到达则输出 −1）。\n\n## 输入输出样例\n### 输入\n```\n3 3 1 1\n```\n### 输出\n```\n0    3    2    \n3    -1   1    \n2    1    4    \n```\n## 说明/提示\n对于全部的测试点，保证 1≤x≤n≤400，1≤y≤m≤400。\n\n## 解析\n裸bfs\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m,x,y;\n// 记录马的移动位置\nint dx[8]={-1,1,-2,2,2,1,-1,-2};\nint dy[8]={2,2,1,1,-1,-2,-2,-1};\nint mapp[401][401];\nstruct node{\n    int x;\n    int y;\n    int k;\n};\n\nint bfs(){\n    queue<node> q;\n    struct node start;\n    start.x = x;\n    start.y = y;\n    start.k = 0;\n    q.push(start);\n    memset(mapp,-1,sizeof(mapp));\n    mapp[x][y]=0;\n    while(!q.empty()){\n        struct node p;\n        p=q.front();\n        q.pop();\n        for(int i=0; i<8; i++){\n            int nx = p.x+dx[i];\n            int ny = p.y+dy[i];\n            if(nx>=1 && ny>=1 && nx<=n && ny<=m){\n            	// -1 表示没到过该点\n                if(mapp[nx][ny]==-1){\n                    mapp[nx][ny]=p.k+1;\n                    struct node np;\n                    np.x = nx;\n                    np.y = ny;\n                    np.k = p.k+1;\n                    q.push(np);\n                }\n            }\n        }\n    }\n}\n\n\nint main() {\n    cin>>n>>m;\n    cin>>x>>y;\n    bfs();\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=m; j++){\n        	// 输出格式，五格范围\n            printf(\"%-5d\", mapp[i][j]);\n        }\n        printf(\"\\n\");\n    }\n	return 0;\n}\n```\n', NULL, '1,2,4', '4', 1, 0, 0, '2023-01-23 10:47:15', '2023-01-23 10:47:45');
INSERT INTO `article` VALUES (45, 1, '【洛谷】P2036-PERKET-dfs', '\n## 题目描述\nPerket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 n 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 s 和苦度 b。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。\n\n众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。\n\n另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。\n\n## 输入格式\n\n第一行一个整数 n，表示可供选用的食材种类数。\n\n接下来 n 行，每行 2 个整数 si 和 bi，表示第 i 种食材的酸度和苦度。\n\n## 输出格式\n一行一个整数，表示可能的总酸度和总苦度的最小绝对差。\n\n## 输入输出样例\n### 输入\n```\n4\n1 7\n2 6\n3 8\n4 9\n```\n### 输出\n```\n1\n```\n## 说明/提示\n\n对于 100% 的数据，有 1≤n≤10，且将所有可用食材全部使用产生的总酸度和总苦度小于 1×10^9^，酸度和苦度不同时为 1 和 0。\n## 解析\n简单的dfs，暴搜就行，搜索之前先设置此次搜索要选择几个数据，可以简化逻辑\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nint ans=1e9;\nint flag[10];\nstruct data{\n    int s;\n    int b;\n};\nstruct data arr[10];\n\n// select 当前选择了几个数据 selected 要选择几个数据\n// sSum 酸度乘积 bSum 苦度总和 \nvoid dfs(int select,int selected, int sSum, int bSum){\n    if(select == selected){\n        ans = min(abs(sSum-bSum), ans);\n    } else {\n        for(int i=0; i<n; i++){\n            if(!flag[i]){\n                flag[i]=1;\n                dfs(select+1, selected, sSum*arr[i].s, bSum+arr[i].b);\n                flag[i]=0;\n            }\n        }\n    }\n\n}\n\nint main() {\n\n    scanf(\"%d\", &n);\n    for(int i=0; i<n; i++){\n        scanf(\"%d%d\", &arr[i].s, &arr[i].b);\n    }\n\n    for(int i=1; i<=n; i++){\n        dfs(0, i, 1, 0);\n    }\n\n    cout<<ans<<endl;\n	return 0;\n}\n```\n', NULL, '1,2,4', '4', 1, 0, 0, '2023-01-23 10:51:02', '2023-01-23 10:51:02');
INSERT INTO `article` VALUES (46, 1, '【洛谷】P2392-kkksc03考前临时抱佛脚-01背包', '## 题目描述\n\n\n这次期末考试，kkksc03 需要考 44 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1, s2, s3, s4 道题目，完成每道题目需要一些时间，可能不等（A1, A2,…,As1，B1,B2,…,Bs2，C1,C2 ,…,Cs3，D1,D2,…,Ds4）。\n\nkkksc03 有一个能力，他的左右两个大脑可以同时计算 2 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。\n\n由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。\n\n## 输入格式\n\n\n本题包含 55 行数据：第 11 行，为四个正整数 s1, s2, s3, s4 。\n\n第 2 行，为 A1,A2,…,As1 共 s1 个数，表示第一科习题集每道题目所消耗的时间。\n\n第 3 行，为 B1,B2,…,Bs2 共 s2 个数。\n\n第 4 行，为 C1,C2,…,Cs3 共 s3 个数。\n\n第 5 行，为 D1,D2,…,Ds4 共 s4 个数，意思均同上。\n\n## 输出格式\n输出一行,为复习完毕最短时间。\n\n## 输入输出样例\n### 输入\n```\n1 2 1 3		\n5\n4 3\n6\n2 4 3\n```\n### 输出\n```\n20\n```\n## 说明/提示\n1≤s1, s2, s3, s4 ≤20。\n\n1≤A1, A2,…,As1，B1,B2,…,Bs2，C1,C2 ,…,Cs3，D1,D2,…,Ds4≤60。\n## 解析\n看题目数据范围不是很大，暴搜应该也可以解决，不过我的解法是背包的思路。\n首先有四科习题，但是每次只能是对同一科的习题进行同时计算，所以只需要依次算出每科习题的最短时间求和就行，因为结果互不影响。单独算一组习题需要将这组习题分成俩个小组，并且这俩组的差值要最小，所以我选用的思路是设置一个背包，背包容量是所有习题时间的总和的一半，然后让这个背包尽可能的装满。\n\n\n\n```c++\n// 二维dp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint s[4];\nint arr[4][21];\nint dp[21][1201],sum;\n\nint backpack(int k){\n    int n = s[k];\n    for(int i=1; i<=n; i++){\n        for(int j=1; j<=sum; j++){\n            if(arr[k][i]>j){\n                dp[i][j] = dp[i-1][j];\n            } else {\n                dp[i][j] = max(dp[i-1][j-arr[k][i]] + arr[k][i], dp[i-1][j]);\n            }\n        }\n    }\n    return dp[n][sum];\n}\n\nint main() {\n\n    for(int i=0; i<4; i++){\n        cin>>s[i];\n    }\n    int ans=0;\n    for(int i=0; i<4; i++){\n        int k = s[i];\n        sum=0;\n        int all;\n        for(int j=1; j<=k; j++){\n            cin>>arr[i][j];\n            sum+=arr[i][j];\n        }\n        all = sum;\n        sum/=2;\n        ans += all - backpack(i);\n    }\n    cout<<ans<<endl;\n	return 0;\n}\n\n// 一维dp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint s[4];\nint arr[4][21];\nint dp[1201],sum;\n\nint backpack(int k){\n    int n = s[k];\n    memset(dp, 0, sizeof(dp));\n    for(int i=1; i<=n; i++){\n        for(int j=sum; j>=0; j--){\n            int x = arr[k][i];\n            if(j>=x){\n                dp[j] = max(dp[j], dp[j-x]+x);\n            }\n        }\n    }\n    return dp[sum];\n}\n\nint main() {\n\n    for(int i=0; i<4; i++){\n        cin>>s[i];\n    }\n    int ans=0;\n    for(int i=0; i<4; i++){\n        int k = s[i];\n        sum=0;\n        int all;\n        for(int j=1; j<=k; j++){\n            cin>>arr[i][j];\n            sum+=arr[i][j];\n        }\n        all = sum;\n        sum/=2;\n        ans += all - backpack(i);\n    }\n    cout<<ans<<endl;\n	return 0;\n}\n```\n', NULL, '1,2', '', 1, 0, 0, '2023-01-23 10:52:15', '2023-01-23 10:52:15');
INSERT INTO `article` VALUES (47, 1, '【洛谷】P3817-小A的糖果-贪心', '## 题目描述\n\n小 A 有 n 个糖果盒，第 i 个盒中有 ai 颗糖果。\n小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 x，至少得吃掉几颗糖。\n\n## 输入格式\n\n输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 n 和给定的参数 x 。\n\n第二行有 n 个用空格隔开的整数，第 i 个整数代表第 i 盒糖的糖果个数 ai 。\n\n## 输出格式\n输出一行一个整数，代表最少要吃掉的糖果的数量。\n## 数据范围\n```\n对于 30% 的数据，保证 n≤20，ai, x ≤ 100\n对于 70% 的数据，保证 n≤10^3 ，ai, x ≤10^5 \n对于 100% 的数据，保证 2≤n≤10^5 , 0≤ai ,x≤10^9\n```\n\n## 输入输出样例\n### 输入\n```\n6 1\n1 6 1 2 0 4\n```\n### 输出\n```\n11\n```\n### 提示\n>第 2 盒糖吃掉 66 颗，第 4 盒吃掉 22 颗，第 6 盒吃掉 33 颗\n## 解析\n判断相邻俩盒糖果数量是否大于x，只需要从头开始遍历数组判断当前盒中糖果数量是否大于x和当前糖果盒和前一个糖果盒中糖果数量之和是否大于x（当前盒和下一盒可以等效替换），还有就是吃糖果要优先吃当前这盒中的，这样可以使下一盒结果最优。\n代码如下：\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n#define MAXN 100001\n\nint n,x;\nint arr[MAXN];\n// \nlong long ans=0;\n\nint main(){\n    scanf(\"%d%d\", &n,&x);\n    for(int i=0; i<n; i++){\n        scanf(\"%d\", &arr[i]);\n    }\n    if(arr[0]>x){\n        ans = arr[0]-x;\n        arr[0] = x;\n    }\n    for(int i=1; i<n; i++){\n        if(arr[i]>x){\n            ans += arr[i]-x;\n            arr[i] = x;\n        }\n        if(arr[i]+arr[i-1]>x){\n            ans += arr[i]+arr[i-1]-x;\n            arr[i]=x-arr[i-1];\n        }\n    }\n\n    printf(\"%lld\", ans);\n    return 0;\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-01-25 10:54:31', '2023-01-25 10:54:46');
INSERT INTO `article` VALUES (48, 1, '【公司】约瑟夫环问题-递归解法', '## 题目描述\n公司绝对按照最近很火的《鱿鱼游戏》一样，再年会上设置一个只有一个人能获得的超级大奖。\n\n游戏规则如下：\n\n参与抽奖的总共有m人，按照1-m号围成一个大圈。\n\n从编号1开始报数，当报到N的时候，将该人淘汰。然后从下一个人开始，继续从1开始报数，到N时被淘汰，直到只剩一人时，获得大奖。\n\n如果你想获得大奖，你得在第一时间 抢占哪个编号才行？\n\n## 输入\n输入只有一行 包含两个整数  分别为m和n\nM代表参赛的总人数 所有人按照1-M编号\nN代表疏导N时被淘汰 \n\n\n1<m<0x7fffffff\n1<n<0x7fffffff\n\n## 输出\n输出最终会获胜的那个编号\n\n## 样例输入\n10 7\n## 样例输出\n9\n## 提示\n输入m可能是一个非常大的数值 这个时候怎么才能快速找到结果\n该题中包含了 可能需要使用复杂度为 O（N）的方法才能在满足时间和内存的条件下，获得结果\n\n如果只能完成50% 可以尝试已在在 m*n 大于  10^10的情况下 程序是否能在5秒内完成\n\n## 解析\n本题是约瑟夫环的一个考察，如果直接保存每一个人的状态按照顺序一步步模拟的话，会因为超时或者内存超限导致失败。\n使用递归需要注意递归有爆栈的风险。\n\n。。。\n\n```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n    只要 m >> n，算法的时间复杂度就只有 O(1) ，否则就退化为原来的递归算法\n*/\nint f1(int m, int n) {\n    int result = 1;\n    int del;\n    for (int i = 2; i <= m; i++){\n        if (result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n - 1) % i + 1;\n    }\n    return result;\n}\n/**\n    递归式:\n    f(1)=0; 第一个位置永远为0\n    f(i)=f(i)+m%n;\n*/\nint f2(int m, int n){\n    int result = 0;\n    int del;\n    for (int i=2; i<= m; i++){\n        if(result + n < i){\n            del = (i - result) / n;\n            if (del > m - i){\n                del = m - i;\n            }\n            i = i + del;\n            result = result + n * del;\n        }\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n/**\n    f3/f4 方法类似\n*/\nint f3(int m, int n){\n    int result = 0;\n    for (int i=2; i<= m; i++){\n        result = (result + n)%i ;\n    }\n    return result+1;\n}\n\nint f4(int m, int n){\n    int result = 1;\n    for(int i=2; i<=m; i++){\n        result = (result + n - 1)%i + 1;\n    }\n    return result;\n}\n/**\n    递归暴力解题，输入m = 10w就会爆栈\n*/\nint f5(int m, int n) {\n    if(m == 1) {\n        return 0;\n    } else {\n        return (f3(m-1, n) + n) % m;\n    }\n}\n\nint main(){\n    int m,n;\n\n    cin>>m>>n;\n\n    cout<<f1(m,n)<<endl;\n\n    cout<<f2(m,n)<<endl;\n\n    cout<<f3(m,n)<<endl;\n\n    cout<<f4(m,n)<<endl;\n\n    cout<<f5(m,n)<<endl;\n\n}\n```\n', NULL, '1', '', 1, 0, 0, '2023-01-25 10:56:33', '2023-01-25 10:56:33');
INSERT INTO `article` VALUES (49, 1, '【公司】最长子串问题-双指针解法', '\n## 题目描述\n产品业务较复杂时，用户程序在实现某一个特定功能时，往往需要与底层模块进行多次交互，然后组合获取的底层结果，最终完成用户功能。\n\n实际上，一个底层模块，由于自身框架设计等原因，导致对外协议接口使用上会存在很多限制，用户程序需要严格根据底层模块的协议来进行交互。\n\n假设存在底层模块，对外提供n种不同交互命令X，编号依次为X1，...，Xn，互不相等，\n\n模块具有如下限制：模块先对接收到的命令进行过滤，提取序列中最长的没有重复的命令序列，如n=7，应用下发命令序列如下：\n\nX1 X2 X3 X1 X5 X4 X2 X5 X7 X6 X1 X3 X2 X3 \n\n\n因此该序列中，最长的没有重复有效命令序列为  X4 X2 X5 X7 X6 X1 X3 ，即最多命令数为 7\n\n简化上述过程，求解出 应用有效命令序列中最多命令数？\n\n## 解析\n题目大概就是求最长不重复子串（子串：原序列中必须连续的一段；子序列：原序列中可以不连续的一段），我这里采用的方法是双指针\n\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/f89b5fef965534bbe79b87bdc7cced71.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/c22f22b74c3de9aa916e53e5edbee783.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/327b2aa05c7ba564af493ded610a537b.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/0b810aeb48d8ab236cfa61be56b277a7.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/281e3e856ce039032172e904ebe462a0.png?imageView2/2/w/1620\nhttps://ask.qcloudimg.com/http-save/yehe-8271427/2e39d2018f01d93a6bf4521356dd86b5.png?imageView2/2/w/1620\n\n![1](https://ask.qcloudimg.com/http-save/yehe-8271427/f89b5fef965534bbe79b87bdc7cced71.png?imageView2/2/w/1620)\n![2](https://ask.qcloudimg.com/http-save/yehe-8271427/c22f22b74c3de9aa916e53e5edbee783.png?imageView2/2/w/1620)\n![3](https://ask.qcloudimg.com/http-save/yehe-8271427/327b2aa05c7ba564af493ded610a537b.png?imageView2/2/w/1620)\n![4](https://ask.qcloudimg.com/http-save/yehe-8271427/0b810aeb48d8ab236cfa61be56b277a7.png?imageView2/2/w/1620)\n![5](https://ask.qcloudimg.com/http-save/yehe-8271427/281e3e856ce039032172e904ebe462a0.png?imageView2/2/w/1620)\n![6](https://ask.qcloudimg.com/http-save/yehe-8271427/2e39d2018f01d93a6bf4521356dd86b5.png?imageView2/2/w/1620)\n\n```c++\n// 本蒟蒻的解法\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\n// 公司题目里面没说n的取值范围\nint arr[10010];\nint main(){\n    scanf(\"%d\",&N);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d\",&arr[i]);\n    }\n    // s表示头指针，e表示尾指针，l记录结果\n    int s=0,l=1;\n    for(int e=0; e<N; e++) {\n        for(int j=s; j<e; j++) {\n            if(arr[j] == arr[e]){\n                s = j+1;\n            }\n        }\n        l = max(l, e-s+1);\n    }\n    printf(\"%d\\n\", l);\n}\n```\n\n```c++\n// 大佬的解法Orz\n# include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint arr[100010], s[100010];\nint N;\n\nint main(){\n    int l=1;\n    scanf(\"%d\", &N);\n    for (int i=0,j=0; i<N; i++){\n        scanf(\"%d\",&arr[i]);\n        ++ s[arr[i]];\n        while (s[arr[i]] > 1) -- s[arr[j++]];\n        l = max(l, i-j+1);\n    }\n    printf(\"%d\\n\",l);\n    return 0;\n}\n```', NULL, '1', '', 1, 0, 0, '2023-01-25 10:57:49', '2023-01-25 11:00:43');
INSERT INTO `article` VALUES (50, 1, '【洛谷】P2820 并查集', '## 题目\n某个局域网内有 n(n≤100) 台计算机，由于搭建局域网时工作人员的疏忽，现在局域网内的连接形成了回路，我们知道如果局域网形成回路那么数据将不停的在回路内传输，造成网络卡的现象。因为连接计算机的网线本身不同，所以有一些连线不是很畅通，我们用 f(i,j) 表示 i,j 之间连接的畅通程度，f(i,j) 值越小表示 i,j 之间连接越通畅，f(i,j) 为 0 表示 i,j 之间无网线连接。\n## 题目描述\n需要解决回路问题，我们将除去一些连线，使得网络中没有回路，并且被除去网线的 ∑f(i,j) 最大，请求出这个最大值。\n## 输入格式\n第一行两个正整数 n,k。\n接下来的 k 行每行三个正整数 i,j,m 表示 i,j 两台计算机之间有网线联通，通畅程度为 m。\n## 输出格式\n一个正整数，∑f(i,j) 的最大值。\n\n## 解析\n根据题目可知，局域网是全部联通的，只是有多余线路导致整个网络形成了回路，要求出被除去网线的 ∑f(i,j)，也就是要使用最少的 ∑f(i,j) ，将网络连接起来（把 ∑f(i,j) 看作俩台电脑之间所连网线的长度会好理解一些），所以我可以先把所有电脑网线都拔开，然后使用最短的网线将这些电脑连接起来，剩余的网线长度就是被除去网线长度的最大值。\n\n```c++\n#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\nint N,K;\n// 用来记录输入的结构体\nstruct cpt{\n    int x,y,l;\n};\n// 100台电脑最大连接数量也就是4950，下标从1开始，所以4951刚刚好\nstruct cpt c[4951];\n// 使用并查集，用来记录每台电脑的上级，下标从1开始\nint par[101];\n// 并查集find函数，用来寻找某节点的上级\nint find1(int x) {\n    int r=x;\n    // 寻找该节点的上级，直到找到一个节点的上级就是自己退出循环\n    while(par[r]!=r){\n        r=par[r];\n    }\n    // 此处 r 表示传入 x 的最上级\n    int i=x,j;\n    // 压缩路径，将传入 x 的上级设为 r\n    while(i!=j){\n        j=par[r];\n        par[i]=j;\n        i=j;\n    }\n    return r;\n}\n// 并查集join函数，用来将新的节点加入网络\nvoid join(int x, int y) {\n	// 如果上级不一样，修改设置为相同\n    int fx=find1(x), fy=find1(y);\n    if(fx!=fy){\n        par[fx]=fy;\n    }\n}\n// 检查par数组中有几个区块（有几个上级为自己的节点）\nint check(){\n    int sum = 0;\n    for(int i=1; i<=N; i++)\n        if(par[i]==i)\n            sum ++;\n    return sum;\n}\n// 使用快排的cmp，从小到大\nbool cmp(cpt a, cpt b){\n    return a.l<b.l;\n}\n\nint main(){\n	// 用来记录网络中网线的最大长度\n    int length=0;\n    scanf(\"%d%d\",&N,&K);\n    for(int i=1; i<=N; i++)\n        par[i]=i;	// 设置每台电脑的上级都为自己\n    for(int i=1; i<=K; i++){\n        scanf(\"%d%d%d\",&c[i].x,&c[i].y,&c[i].l);\n        // 记录网线长度\n        length+=c[i].l;\n    }\n    // 将所有节点之间的连接按照网线长度进行排序\n    sort(c+1, c+1+K, cmp);\n    // 对所有网线进行循环\n    for(int i=1; i<=K; i++){\n        int r1 = find1(c[i].x);\n        int r2 = find1(c[i].y);\n        // 如果这两台电脑的上级不同，则使用网线将这俩个区块连接起来\n        // 上级不同说明这两台电脑之间没有连接，此时取出的网线长度还是从小到大排列的\n        // 所以使用这个网线连接可以确保使用的是最短的网线\n        if(r1 != r2){\n            join(c[i].x,c[i].y);\n            // 从总长度中减去使用的网线长度\n            length-=c[i].l;\n        }\n    }\n    // 剩余的长度即为最大长度\n    printf(\"%d\",length);\n}\n\n```', NULL, '1,2', '', 1, 0, 0, '2023-01-25 11:01:31', '2023-01-25 11:01:31');
INSERT INTO `article` VALUES (51, 1, 'MySQL学习(一):存储过程以及定时任务', '# 存储过程\n	首先在navcat事件中创建存储过程,然后再开始代码编写\n```sql\n# IN表示传入参数,多个参数逗号隔开 格式: IN <name> <type>\nCREATE DEFINER=`mysql`@`127.0.0.1` PROCEDURE `UPDATE_ONLINE_SUMMARY_BY_MONTH`(IN tableName varchar(100))\nBEGIN\n\n# DATE_FORMAT(date,format)函数 date:传入日期 format:输出格式\n# 输出格式: %Y 年,4位,y小写俩位 %m 月,m大写是英文名 %d 日,d大写有英文后缀,例22nd\n# NOW() 返回当前日期\nSET @myYear = DATE_FORMAT(NOW(), \'%Y\');\nSET @myMonth = DATE_FORMAT(NOW(), \'%m\');\n# CONCAT() 字符串拼接函数,多个字符串用逗号隔开\nSET @saveDate = CONCAT(@myYear,\'_\' , @myMonth - 1);\nIF @myMonth > 6 THEN\n	SET @delDate = CONCAT(@myYear, \'_\', @myMonth - 6);\nELSE\n	SET @delDate = CONCAT(@myYear - 1, \'_\', @myMonth + 6);\nEND IF;\n\n#删除六个月之前的表格\nSET @deleteTableName = CONCAT(\'DROP TABLE IF EXISTS `\' , tableName , \'_\', @delDate , \'`;\');\n# PREPARE基本用法\n# PREPARE stmt from \'你的sql语句\';\n# EXECUTE stmt (如果sql有参数的话, USING xxx,xxx); // 这里USING的只能是会话变量\n# 会话变量: 例: SET @变量=值\n# DEALLOCATE PREPARE stmt;  // 释放连接\nPREPARE stmt FROM @deleteTableName;\nEXECUTE stmt;\n \n#重命名上个月的表\nSET @renameTableName = CONCAT(\'rename table \' , tableName , \' to \' , tableName, \'_\' , @saveDate , \';\');\nPREPARE stmt FROM @renameTableName;\nEXECUTE stmt;\n# sql的if elseif 语句格式\nIF tableName = \'adm_chn_online_summary\' THEN\n	#创建新表\n	SET @createStr = CONCAT(\"CREATE TABLE `adm_chn_online_summary` (\n		`ID` bigint(20) NOT NULL AUTO_INCREMENT,\n		`DEVICE_CODE` varchar(50) NOT NULL COMMENT \'设备code\',\n		`CHANNEL_SEQ` int(10) NOT NULL COMMENT \'通道号\',\n		`ONLINE_SECOND` bigint(20) NOT NULL COMMENT \'在线时长,单位秒\',\n		`ONLINE_RATE` double(20,2) NOT NULL COMMENT \'每日在线率，小数点保留二位\',\n		`DATE` datetime NOT NULL COMMENT \'统计日期，用于分组\',\n		`SAVE_DATE` datetime NOT NULL COMMENT \'数据插入时间，保留数据生成的时间点\',\n		`DESCRIBE_LIST` mediumtext COMMENT \'用于前端展示数据，展示具体的时间点在线和离线状态\',\n		PRIMARY KEY (`ID`),\n		KEY `INDEX_DEVICE_CODE` (`DEVICE_CODE`) USING BTREE,\n		KEY `INDEX_DATE` (`DATE`) USING BTREE\n	) ENGINE=InnoDB AUTO_INCREMENT=222357 DEFAULT CHARSET=utf8;\");\n	PREPARE stmt FROM @createStr;\n	EXECUTE stmt;\nELSEIF tableName = \'adm_dev_online_summary\' THEN\n	#创建新表\n	SET @createStr = CONCAT(\"CREATE TABLE `adm_dev_online_summary` (\n		`ID` bigint(20) NOT NULL AUTO_INCREMENT,\n		`DEVICE_CODE` varchar(50) CHARACTER SET utf8 NOT NULL COMMENT \'设备编号\',\n		`ONLINE_SECOND` bigint(20) NOT NULL COMMENT \'在线时长,单位秒\',\n		`ONLINE_RATE` double(20,2) NOT NULL COMMENT \'每日在线率，小数点保留二位\',\n		`DATE` datetime NOT NULL COMMENT \'统计日期，用于分组\',\n		`SAVE_DATE` datetime NOT NULL COMMENT \'数据插入时间，保留数据生成的时间点\',\n		`DESCRIBE_LIST` mediumtext CHARACTER SET utf8 COMMENT \'用于前端展示数据，展示具体的时间点在线和离线状态\',\n		PRIMARY KEY (`ID`)\n	) ENGINE=InnoDB AUTO_INCREMENT=24382 DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'设备在线时长统计表\';\");\n	PREPARE stmt FROM @createStr;\n	EXECUTE stmt;\nEND IF;\n\nDEALLOCATE PREPARE stmt;\nEND\n```\n\n# 定时任务\n```sql\nbegin\n\ncall UPDATE_ONLINE_SUMMARY_BY_MONTH(\'adm_chn_online_summary\');\ncall UPDATE_ONLINE_SUMMARY_BY_MONTH(\'adm_dev_online_summary\');\n\nend\n```\n然后在计划中添加执行时间', NULL, '5', '', 1, 0, 0, '2023-01-25 11:06:48', '2023-01-25 11:06:48');
INSERT INTO `article` VALUES (52, 1, 'Spring注解 @Scheduled', '# Scheduled注解中的cron表达式含义\ncron有6-7个用空格分开的时间元素\n## 时间元素\n| 字段 | 范围 | 允许的特殊值 |\n|--|--|-|\n| 秒 | 0-59 | , - * / |\n| 分 | 0-59 | , - * / |\n| 小时 | 0-59 | , - * / |\n| 日期 | 1-31 | , - * ? / L W C |\n| 月份 | 1-12(常用,也可以英文前三个字母) | , - * / |\n| 星期 | 1-7(常用,也可以SUN - SAT) | , - * ? / L C # |\n| 年(可选) | 1970-2099 | , - * / |\n\n```c\ncron表达式中6个元素依次分别表示: 秒, 分, 时, 日期, 月份, 星期, 年(可以省略)\n例1: 0 0 10,14 * * ?\n\'*\' 表示通配符,代表所有可能\n\'?\' \'?\'只用于日期和星期,因为星期和日期会冲突,所以必须有一个为\'?\'\n\',\' 表示一个列表,所以表达式为每天10点和下午2点\n例2: 0 0 10-14 * * ?\n\'-\' 表示一个连续区间,所以表达式为每天10点到下午2点\n例3: 0 0 10-14/1 * * ?\n\'/\' 表示间隔时间,所以表达式为每天10点到下午2点每隔1个小时\n例4: 0 0/5 10 * * ?\n0/15 表示从0分钟开始增量为15,和 0,15,30,45 含义一样\n3-15 表示从第3分钟开始增量为15,\'/\'左边不是必须为0或者一个连续区间\n表达式意思为: 每天10点到10:59之间每隔5分钟触发\n例5: 0 15 10 ? * 6L\n\'L\' 表示最后,last的简写,所以表达式意思是: 每个月最后一个周五的10:15分开始执行\n至于为什么6L是最后一个周五,是因为星期是 7 1 2 3 4 5 6 顺序排列,所以6表示周五\n例6: 0 0 12 W * ?\n\'W\' 表示工作日,所以表达式为每个工作日的12点\n\'LW\' 连用即表示最后一个工作日\n\'C\' 指和calendar联系后计算过的值 例：在日期字段用“5C”指在这个月第5天或之后包括calendar的第一天,在星期字段用“1C”指在这周日或之后包括calendar的第一天,因为不会用所以不写示例\n例7: 0 15 10 ? * 6#3 \n\'#\' 用于确定每个月的第几个星期几,只出现在星期字段中, #后面是第几个,前面是星期几 所以表达式为每个月第三个星期五的10点15分\n```\nhttps://www.jianshu.com/p/1979cadc0dd0', NULL, '6,7', '', 1, 0, 0, '2023-01-25 11:08:14', '2023-01-25 11:08:14');
INSERT INTO `article` VALUES (53, 1, 'Centos7安装MongoDB-5.0.2', '@[TOC](目录)\n# 1.下载MongoDB安装包\n下载 [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)\n选择MongoDB Community Server\nVersion：5.0.2（current）\nPlatform：RedHat / CentOS 7.0\nPackage：tgz\n安装位置：/usr/local/mongodb\n```shell\n# 进入指定位置下载安装包\ncd /usr/local\n# 下载安装包\nwget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-5.0.2.tgz\n# 解压安装包\ntar -zxvf mongodb-linux-x86_64-rhel70-5.0.2.tgz\n# 改名字\nmv mongodb-linux-x86_64-rhel70-5.0.2 mongodb\n# 此时可以删除安装包\nrm -rf mongodb-linux-x86_64-rhel70-5.0.2.tgz \n```\n# 2.配置环境变量\n```shell\n# 配置环境变量\nvim /etc/profile\n\n## 文件中写入\nexport MONGO_HOME=/usr/local/mongodb\nexport PATH=$PATH:$MONGO_HOME/bin;\n## 然后按下shift+俩次 z 键，保存输入信息\n# 更新\nsource /etc/profile\n```\n# 3.建立日志、数据文件夹、配置文件夹\n```shell\n# 在 /usr/local/mongodb 路径下创建，如果不是需要切换进入\ncd /usr/local/mongodb\n# 创建三个文件夹\nmkdir logs data conf\n# 进入conf文件夹（写全路径防止大家走错位置）\ncd /usr/local/mongodb/conf\n# 写配置文件信息\nvim mongodb.conf\n## 内容如下\nport=27017 #端口\nbind_ip=0.0.0.0 #默认是127.0.0.1\ndbpath=/usr/local/mongodb/data #数据库存放\nlogpath=/usr/local/mongodb/logs/mongodb.log #日志文件\nfork=true #设置后台运行\n#auth=true #开启认证\n```\n# 4.启动MongoDB\n```shell\n# 启动命令\n./mongod --config /usr/local/mongodb/conf/mongodb.conf\n# 此处.conf文件路径一定不能出错\n```\n# 5.连接\n```shell\n# 输入mongo即可\nmongo\n```', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:10:32', '2023-01-25 11:10:32');
INSERT INTO `article` VALUES (54, 1, 'Centos7安装MySQL-5.7', '# 一、安装MySQL源\n```shell\n# 下载mysql安装包\nwget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm\n# 安装源\nyum -y localinstall mysql57-community-release-el7-11.noarch.rpm\n```\n# 二、yum安装MySQL\n```shell\n yum -y install mysql-community-server\n```\n# 三、启动MySQL服务\n```shell\nsystemctl start mysqld\n```\n\n# 四、设置开机启动\n```\nsystemctl enable mysqld\nsystemctl daemon-reload\n```\n# 五、登录MySQL\n	查看MySQL密码\n```shell\ncat /var/log/mysqld.log\n```\n	登录密码为下图所示位置密码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/fad16c42ce41475c8a0a10313a171208.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6JKfLeiSuw==,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n```sql\nmysql -u root -p\n```\n# 六、修改MySQL密码\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'root\'; \n```\n如果提示报错：ERROR 1819 (HY000): Your password does not satisfy the current policy requirements \n则需要修改MySQL的密码策略\n因为不修改密码不允许查看密码策略，所以需要先符合密码策略修改一次\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'MySQL123@*\'; \n```\n\n## 1、查看 mysql 初始的密码策略，\n输入语句以下进行查看，\n```sql\nSHOW VARIABLES LIKE \'validate_password%\';\n```\n```\n1）、validate_password_length  固定密码的总长度；\n2）、validate_password_dictionary_file 指定密码验证的文件路径；\n3）、validate_password_mixed_case_count  整个密码中至少要包含大/小写字母的总个数；\n4）、validate_password_number_count  整个密码中至少要包含阿拉伯数字的个数；\n5）、validate_password_policy 指定密码的强度验证等级，默认为 MEDIUM；\n关于 validate_password_policy 的取值：\n0/LOW：只验证长度；\n1/MEDIUM：验证长度、数字、大小写、特殊字符；\n2/STRONG：验证长度、数字、大小写、特殊字符、字典文件；\n6）、validate_password_special_char_count 整个密码中至少要包含特殊字符的个数；\n```\n## 2、设置密码的验证强度等级\n	设置 validate_password_policy 的全局参数为 LOW 即可，输入设值语句\n```sql\nset global validate_password_policy=LOW;\n```\n\n## 3、当前密码长度为4\n	可以根据自己相关自定义密码长度，输入设值语句\n```sql\nset global validate_password_length=4;\n```\n\n## 4、修改MySQL密码\n	现在可以为 mysql 设置简单密码了，只要满足四位的长度即可，可自己修改\n```sql\nALTER USER \'root\'@\'localhost\' IDENTIFIED BY \'root\';\n```\n\n# 七、设置远程登陆\n	by之后为远程登陆密码，和本地登陆密码不冲突，123456需自定义修改\n```sql\ngrant all on *.* to root@\'%\' identified by \'123456\' with grant option;\n```', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:11:47', '2023-01-25 11:11:47');
INSERT INTO `article` VALUES (55, 1, 'Centos7安装redis-6.2.5', '# 安装redis-6.2.5\n\n```shell\n# 安装到指定文件夹\ncd /usr/local/\n# 获取redis安装包\nwget https://download.redis.io/releases/redis-6.2.5.tar.gz\n# 解压\ntar -zxvf redis-6.2.5.tar.gz\n# 改名字\nmv redis-6.2.5 redis\n# 进入redis文件夹\ncd redis\n# 执行make命令\nmake\n```\n\n# redis启动\n## 方式一：\n\n```shell\n# 进入src目录\ncd /usr/local/redis/src/\n./redis-server\n```\n缺点：需要一直打开窗口，不能进行其他操作，不太方便\n## 方式二：\n```shell\n# 进入redis文件目录\ncd /usr/local/redis\n# 修改redis配置文件\nvim redis.conf \n# 修改daemonize 选项\n# 将 daemonize no 改为 daemonize yes\n# 进入redis启动文件目录\ncd /usr/local/redis/src\n# 指定redis.conf文件启动\n./redis-server /usr/local/redis/redis.conf\n```\n推荐', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:00', '2023-01-25 11:48:14');
INSERT INTO `article` VALUES (56, 1, 'Centos7安装tomcat-10.0.11', '# Tomcat安装包下载\n\n```shell\n# 进入要安装的文件夹\ncd /usr/local\n# 从官网下载tomcat安装包\nwget https://dlcdn.apache.org/tomcat/tomcat-10/v10.0.11/bin/apache-tomcat-10.0.11.tar.gz\n# 解压安装包\ntar -zxvf apache-tomcat-10.0.11.tar.gz\n# 改个名字\nmv apache-tomcat-10.0.11 tomcat\n# 启动tomcat（要配置好jdk）\ncd tomcat/bin/\n./startup.sh \n# 如果启动成功了，但是自己电脑访问不到 ip:8080页面可能是因为防火墙的原因\n# 放行8080端口\nsystemctl start firewalld\nfirewall-cmd --zone=public --add-port=8080/tcp --permanent\n```\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:24', '2023-01-25 11:14:24');
INSERT INTO `article` VALUES (57, 1, 'Centos安装jdk-17', '# 下载jdk包\n\n```shell\n# 在 /usr/local 目录下安装jdk\ncd /usr/local\nwget https://download.oracle.com/java/17/latest/jdk-17_linux-x64_bin.tar.gz\ntar -zxvf jdk-17_linux-x64_bin.tar.gz \n# 将jdk-17改名为java\nmv jdk-17 java\n```\n\n\n# 添加环境变量\n\n```shell\n# 进入profile文件，按i进入编辑模式\nvim /etc/profile\n# 在文件最下方添加\nexport JAVA_HOME=/usr/local/java\nexport PATH=$PATH:$JAVA_HOME/bin;\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar;\n# 按下Esc退出编辑模式\n# 下一步按住shift 再按俩次 z 键，保存配置文件信息\n# 重新加载环境变量\nsource /etc/profile\n# \ncd /\njava -version\n```\n\n\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:14:48', '2023-01-25 11:14:48');
INSERT INTO `article` VALUES (58, 1, 'Mybatis使用笔记（一）', '# 前言\n```xml\n	<resultMap id=\"BaseResultMap\" type=\"com.spring.demo.entity.Student\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n    </resultMap>\n\n    <sql id=\"All_Menu\">\n        id, student_name, student_sex, student_class, student_age\n    </sql>\n```\n# 查询\n\n```xml\n	<!--无参数-->\n    <select id=\"selectAll\" resultMap=\"BaseResultMap\">\n        select\n        <include refid=\"All_Menu\"/>\n        from student_table\n    </select>\n\n	<!--有参数-->\n    <select id=\"selectById\" resultMap=\"BaseResultMap\" parameterType=\"java.lang.Integer\">\n        select\n        <include refid=\"All_Menu\"/>\n        from student_table\n        where id = #{id, jdbcType=INTEGER}\n    </select>\n```\n\n# 修改\n```xml\n    <update id=\"updateById\" parameterType=\"com.spring.demo.entity.Student\">\n        update student_table\n        <set>\n            <if test=\"studentName != null and studentName != \'\'\">\n                student_name = #{studentName},\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                student_sex = #{studentSex},\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                student_class = #{studentClass},\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                student_age = #{studentAge},\n            </if>\n        </set>\n        <where>\n            id = #{id}\n        </where>\n    </update>\n```\n# 插入\n```xml\n	<!--插入一个学生信息-->\n    <insert id=\"insertStudent\" parameterType=\"com.spring.demo.entity.Student\">\n        insert into student_table\n        <trim prefix=\"(\" suffix=\")\" suffixOverrides=\",\">\n            <if test=\"studentName != null and studentName != \'\'\">\n                student_name,\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                student_sex,\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                student_class,\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                student_age,\n            </if>\n        </trim>\n        <trim prefix=\"values (\" suffix=\")\" suffixOverrides=\",\">\n            <if test=\"studentName != null and studentName != \'\'\">\n                #{studentName, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentSex != null and studentSex != \'\'\">\n                #{studentSex, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentClass != null and studentClass != \'\'\">\n                #{studentClass, jdbcType=VARCHAR},\n            </if>\n            <if test=\"studentAge != null and studentAge != \'\'\">\n                #{studentAge, jdbcType=VARCHAR},\n            </if>\n        </trim>\n    </insert>\n	<!--插入一个学生信息列表-->\n    <insert id=\"insertStudentList\">\n        insert into student_table (student_name, student_sex, student_class, student_age)\n        values\n        <foreach collection=\"list\" item=\"item\" separator=\",\">\n            (#{item.studentName}, #{item.studentSex},\n            #{item.studentClass}, #{item.studentAge})\n        </foreach>\n    </insert>\n```\n# 删除\n```xml\n    <!--通过id删除信息-->\n    <delete id=\"deleteStudentById\" parameterType=\"java.lang.Integer\">\n        delete from student_table where id = #{id}\n    </delete>\n    <!--传入List删除-->\n    <delete id=\"deleteByIdList\" parameterType=\"java.util.List\">\n        delete from student_table\n        where id in (\n        <foreach collection=\"list\" item=\"id\" index=\"index\" separator=\",\">\n            #{id}\n        </foreach>\n        )\n    </delete>\n```\n\n# 其它\n## resultType和resultMap的区别：\nresultType是简单的返回类型，比如查询数据只需要一个简单的String、int只需要使用resultType即可满足需求，\nresultMap是resultType的高级版，可以自定义返回类型\n### resultMap：\ncolumn对应数据库中的字段名字，property对应实体类的名字\n## 输入映射parameterType：\n可以传入8种基本数据类型，pojo类型，包装pojo类型（pojo类型再次封装），传入map（在映射文件中获取对应的key， #{key}）\n', NULL, '10,12', '', 1, 0, 0, '2023-01-25 11:16:18', '2023-01-25 11:42:38');
INSERT INTO `article` VALUES (59, 1, 'Mybatis使用笔记（二）', '# Mybatis查询之resultMap的使用\n\n使用result的高级功能，一对一映射、一对多映射以及多对多映射\n一对一映射对应的标签为association，一对多映射对应的标签为collection\n一对一映射使用包装对象实现，例如：要查找学生和班级，但是学生信息以及班级信息在两个类中，可以将班级类型作为一个对象包装进入学生类中\n```java\n@Data\npublic class Student {\n    private Integer id;\n    private String studentName;\n    private String studentSex;\n    private Integer studentClass;\n    private Integer studentAge;\n\n    private ClassEntity classEntity;\n}\n```\nassociation和collection二者标签的内部属性基本是一致的，它们的属性介绍如下：\n\n - （常用）property：映射 实体类属性名。 \n - （常用）column：映射数据库字段名或者其别名（这个别名是数据库起的，如 select username as name）。\n - （常用）javaType：映射java类型。 \n - （常用）jdbcType：映射数据库类型。\n - （常用）ofType：映射集合的类型（注意：javaType是用来指定pojo中属性的类型，而ofType指定的是映射到list集合属性中pojo的类型，也就是尖括号的泛型private List<User> users）。 \n - （常用）select：用于加载复杂类型属性的映射语句的id(全限定名加方法，方法名后面无括号，例如：com.thr.mapper.UserMapper.selectAllUser)，它会从column 属性指定的列中检索数据，作为参数传递给目标 select 语句。\n - （常用）fetchType：延迟加载，lazy打开延迟加载，eager积极加载。指定属性后，将在映射中忽略全局配置参数lazyLoadingEnabled，使用属性的值。\n - resultMap：不使用嵌套模式，而是将此关联的嵌套结果集映射到一个外部的<resultMap>标签中，然后通过 id 进行引入。\n - resultSet：指定用于加载复杂类型的结果集名字。\n - autoMapping：自动封装，如果数据库字段和javaBean的字段名一样，可以使用这种方式，但是不建议采取，如果非要使用此功能，那就在全局配置中加上mapUnderscoreToCamelCase=TRUE，它会使经典数据库字段命名规则翻译成javaBean的经典命名规则，如：a_column翻译成aColumn。\n - columnPrefix：关联多张表查询时，为了使列明不重复，使用此功能可以减少开发量。\n - foreignColumn：指定外键对应的列名，指定的列将与父类型中 column 的给出的列进行匹配。\n - notNullColumn：不为空的列，如果指定了列，那么只有当字段不为空时，Mybatis才会真正创建对象，才能得到我们想要的值。\n - typeHandler：数据库与Java类型匹配处理器（可以参考前面的TypeHandler部分）。\n\n# 一对一映射\n## 嵌套查询\n映射xml语句\n```xml\n    <resultMap id=\"StudentClassMap\" type=\"com.spring.demo.entity.Student\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <!--一对一关联对象-->\n        <!--property：映射实体类属性名字-->\n        <!--javaType：映射Java类型-->\n        <association property=\"classEntity\" javaType=\"com.spring.demo.entity.ClassEntity\">\n            <!--property和column表示映射实体类和其表中字段绑定-->\n            <!--此处有一个小问题，就是如果id为 <id property=\"id\" column=\"id\"/> 时，会出现查询结果中的id是学生的id，className没有错误-->\n            <id property=\"classId\" column=\"class_id\"/>\n            <result property=\"className\" column=\"class_name\"/>\n        </association>\n    </resultMap>\n    <!--查询所有数据-->\n    <select id=\"selectStudentClass\" resultMap=\"StudentClassMap\">\n        select * from\n        student_table s,\n        class_table c\n        where\n        s.student_class = c.class_id\n    </select>\n    <!--根据学生id查找其信息-->\n    <select id=\"selectStudentClassById\" parameterType=\"java.lang.Integer\" resultMap=\"StudentClassMap\">\n        select * from\n        student_table s,\n        class_table c\n        where\n        s.student_class = c.class_id\n        and s.id = #{id}\n    </select>\n```\n\n## 分布查询\n```xml\n    <!--分布查询-->\n    <resultMap id=\"StudentClassMap2\" type=\"com.spring.demo.vo.StudentVo\">\n        <id column=\"id\" property=\"id\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_name\" property=\"studentName\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_sex\" property=\"studentSex\" jdbcType=\"VARCHAR\"/>\n        <result column=\"student_age\" property=\"studentAge\" jdbcType=\"INTEGER\"/>\n        <result column=\"student_class\" property=\"studentClass\" jdbcType=\"INTEGER\"/>\n        <!--column为student表中班级字段， property为StudentVo类中班级类名，javaType为班级类，select指定通过id查询班级的接口-->\n        <association column=\"student_class\" property=\"classEntity\" javaType=\"com.spring.demo.entity.ClassEntity\"\n                    select=\"com.spring.demo.dao.ClassDAO.selectById\"/>\n\n    </resultMap>\n    \n    <select id=\"selectStudentClassById_\" parameterType=\"java.lang.Integer\" resultMap=\"StudentClassMap2\">\n        select * from\n        student_table\n        where\n        id = #{id}\n    </select>\n```\n```java\n// studentVo类\n@Data\n// 作用是在 json 序列化时忽略 bean 中的一些不需要转化的属性\n@JsonIgnoreProperties(value = { \"handler\" })\npublic class StudentVo {\n    private Integer id;\n    private String studentName;\n    private String studentSex;\n    private Integer studentClass;\n    private Integer studentAge;\n\n    private ClassEntity classEntity;\n}\n\n```\n## 总结\n分布查询会比嵌套查询多执行几个sql，所以效率上是嵌套查询更好，但是分布查询可以延迟加载（懒加载）\n\n# 一对多映射\n## 嵌套查询\n```xml\n    <resultMap id=\"ClassStudentMap\" type=\"com.spring.demo.vo.ClassEntityVo\">\n        <id column=\"class_id\" property=\"classId\"/>\n        <result column=\"class_name\" property=\"className\"/>\n        <!--一对多映射-->\n        <!--ofType：指定pojo的类型，为list尖括号内部的泛型-->\n        <collection property=\"students\" ofType=\"com.spring.demo.entity.Student\">\n            <id column=\"id\" property=\"id\"/>\n            <result column=\"student_name\" property=\"studentName\"/>\n            <result column=\"student_sex\" property=\"studentSex\"/>\n            <result column=\"student_age\" property=\"studentAge\"/>\n            <result column=\"student_class\" property=\"studentClass\"/>\n        </collection>\n    </resultMap>\n	<!--查询所有班级学生-->\n    <select id=\"selectClassStudent\" resultMap=\"ClassStudentMap\">\n        select * from\n        class_table c,\n        student_table s\n        where\n        c.class_id = s.student_class\n    </select>\n    <!--通过班级id查询班级学生-->\n    <select id=\"selectClassStudentById\" parameterType=\"java.lang.Integer\" resultMap=\"ClassStudentMap\">\n        select * from\n        class_table c,\n        student_table s\n        where\n        c.class_id = s.student_class\n        and c.class_id = #{classId}\n    </select>\n```\n\n## 分布查询\n```xml\n    <resultMap id=\"ClassStudentMap2\" type=\"com.spring.demo.vo.ClassEntityVo\">\n        <id column=\"class_id\" property=\"classId\"/>\n        <result column=\"class_name\" property=\"className\"/>\n        <collection column=\"class_id\" property=\"students\" ofType=\"com.spring.demo.entity.Student\"\n                    select=\"com.spring.demo.dao.StudentDAO.selectByClass\"/>\n    </resultMap>\n    \n    <!--分布查询，通过班级id查询班级学生-->\n    <select id=\"selectClassStudentById_\" parameterType=\"java.lang.Integer\" resultMap=\"ClassStudentMap2\">\n        select * from class_table\n        where class_id = #{classId}\n    </select>\n```', NULL, '10,12', '', 1, 0, 0, '2023-01-25 11:16:43', '2023-01-25 11:42:59');
INSERT INTO `article` VALUES (60, 1, 'Mybatis学习笔记（一）', '# Mybatis的基本概念\n\n - 持久化：将内存中的数据保存在存储设备中\n - 持久层：专注实现数据持久化应用领域的某个系统特定的一个逻辑层面，将数据使用者和数据实体相关联。例如pojo层、Dao层和Service层的关联\n - ORM：对象关系映射，将数据库中的数据与程序中的对象映射，操作数据库时只需要和对象打交道就行，简化了操作。Mybatis是一个半自动化的ORM框架，因为需要写sql语句，Hibernate是一个全自动化的ORM框架\n\n# Mybatis和Hibernate的区别\n## 开发方面\n\n - Hibernate是全自动的ORM映射工具，使用Hibernate查询关联对象或关联集合对象时，可以根据对象关系模型直接获取\n	\n - Mybatis是半自动ORM映射工具，Mybatis在查询关联对象或关联集合对象时需要手动编写sql来完成。Mybatis可以通过注解或XML的方式配置sql，并将java对象和sql语句映射生成最终执行的sql，然后再将结果映射生成Java对象\n\n## 底层\n - Hibernate的底层是JPA规范实现的\n - Mybatis是封装JDBC的代码\n\n## SQL优化方面\n\n - Hibernate自动生成sql相比Mybatis可能会多消耗一些性能\n \n \n## 对象管理方面\n - Hibernate是完整的对象/关系映射的框架，对象/关系映射能力极强，在开发过程中无需过多关注底层实现，只需要管理对象即可；而且数据库无关性好，对于关系模型要求高的软件使用Hibernate可以节省很多代码\n - Mybatis需要自己管理映射关系，并且无法做到数据库无关性，如果要支持多种数据库则需要自定义多套sql映射文件\n \n \n## 日志系统\n - Hibernate日志功能非常健全，Mybatis只有简单的基本记录功能\n \n ## 缓存\n \n - 之后写\n\n# Mybatis的重要组件\n![Mybatis结构](https://img-blog.csdnimg.cn/50615112756f43c59f86e28c8217ca98.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70#pic_center)\n\n - SqlMapConfig.xml：是Mybatis的全局配置文件，主要配置数据源、（事务、加载映射文件）\n - SqlSessionFactoryBuilder：根据xml配置或是Java配置生成SqlSessionFactory对象。采用建造者模\n - SqlSessionFactory：用于生成SqlSession，可以通过SqlSessionFactory.OpenSession()方法创建SqlSession对象。使用工厂模式\n	\n - SqlSession：相当于JDBC的Connection对象，可以用SqlSession实例来直接执行被映射的sql语句，也可以获取相应的Mapper\n	\n - Executor：Mybatis中所有的Mapper语句都是通过Executor执行的\n		\n - Mapper：由XML文件和Java接口组成，根据XML中配置的映射信息执行对应的sql语句并返回执行结果\n	\n - MappedStatement：作用是封装了Statement的相关信息，包括SQL语句、输入参数和输出结果等等\n\n\n\n# Mybatis执行流程\n\n - 首先加载Mybatis的全局配置文件，随后会加载sql映射文件或者注解相关的sql内容\n - 创建会话工厂，Mybatis通过读取配置文件的信息来构造出会话工厂 SqlSessionFactory\n - 创建会话，根据会话工厂Mybatis创建会话对象 SqlSession，会话对象是一个接口包括对数据库的增删改查方法\n - 创建执行器会话不能直接操作数据库，所以使用数据库执行器Executor的接口帮它执行操作\n - 封装sql对象，执行器将待处理的sql信息封装到一个对象中MappedStatement，该对象包括sql语句、输入参数映射信息和输出结果映射信息\n - 操作数据库使用执行器和sql封装对象查询数据库返回结果\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:17:32', '2023-01-25 11:43:07');
INSERT INTO `article` VALUES (61, 1, 'Mybatis学习笔记（二）', '# 前言\nMybatis的使用主要分三个版本\n\n - 基于原生接口的xml版本\n - 基于mapper接口的xml版本\n - 基于Java注解的版本\n\n在实际开发中主要使用基于mapper接口的版本，本章学习主要记录基于原生接口的版本\n\n# 创建数据库\n\n```sql\nDROP TABLE IF EXISTS `t_student`;\nCREATE TABLE `t_student`  (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sex` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `age` int(11) NULL DEFAULT NULL,\n  PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n\n-- ----------------------------\n-- Records of t_student\n-- ----------------------------\nINSERT INTO `t_student` VALUES (1, \'马保国\', \'男\', 44);\nINSERT INTO `t_student` VALUES (2, \'张三\', \'男\', 20);\nINSERT INTO `t_student` VALUES (3, \'李四\', \'男\', 30);\nINSERT INTO `t_student` VALUES (4, \'王五\', \'男\', 40);\nINSERT INTO `t_student` VALUES (5, \'赵六\', \'男\', 10);\nINSERT INTO `t_student` VALUES (6, \'孙七\', \'女\', 35);\nINSERT INTO `t_student` VALUES (7, \'周八\', \'女\', 20);\n\n```\n\n# 创建maven项目\n\n![项目文件](https://img-blog.csdnimg.cn/7da0e27f7ff04e61a6c2e43d42490eed.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70#pic_center)\n\n\n\n导入pom依赖：\n\n```java\n    <dependencies>\n        <!--Mybatis-->\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.7</version>\n        </dependency>\n        <!--MySQL驱动-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>5.1.21</version>\n        </dependency>\n        <!--日志处理-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n        <!--单元测试-->\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.13.1</version>\n            <scope>test</scope>\n        </dependency>\n    </dependencies>\n```\n\n## 编写实体类\n```java\n/**\n * @author: lxk\n * @date: 2021/7/24 22:56\n * @description: 学生实体类\n * @modified By:\n */\npublic class Student {\n    private Integer id;\n    private String name;\n    private String sex;\n    private Integer age;\n	// get set 方法省略\n}\n```\n\n## 创建Mybatis全局配置文件\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n\n<configuration>\n    <!-- 配置环境.-->\n    <environments default=\"development\">\n        <!-- id属性必须和上面的default一致 -->\n        <environment id=\"development\">\n            <!--配置事务的类型-->\n            <transactionManager type=\"JDBC\"/>\n            <!--dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源 -->\n            <dataSource type=\"POOLED\">\n                <!--配置连接数据库的4个基本信息-->\n                <property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/>\n                <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf-8\"/>\n                <property name=\"username\" value=\"root\"/>\n                <property name=\"password\" value=\"mysql\"/>\n            </dataSource>\n        </environment>\n    </environments>\n    <!--指定映射配置文件的位置，这个映射配置文件指的是每个业务独立的配置文件-->\n    <mappers>\n        <mapper resource=\"mapper/StudentMapper.xml\"/>\n    </mappers>\n</configuration>\n\n```\n\n - **environments**：配置当前环境，default属性有development（开发模式 默认）和work（工作模式）两种选择\n - **environment**：配置environment定义的环境，可以配置多个运行环境，但每个SqlSessionFactory实例只能选择一个运行环境\n - **transactionManager**：配置事务管理器类型，type属性有JDBC和MANAGED两种\n**JDBC**使用JdbcTransactionFactory工厂生成的JdbcTranaction对象实现，以JDBC的方式进行数据库的提交回滚等操作，它依赖于从数据源得到的连接来管理事务范围\n **MANAGED**使用ManagedTransactionFactory工厂生成的ManagedTransaction对象实现，它的提交和回滚不需要任何操作，而是把事务交给容器进行处理，默认情况下会关闭连接，可以修改closeConnection属性为false不默认关闭\n - **dataSource**：配置数据源属性，type有UNPOOLED、POOLED和JNDI三种选择\n**UNPOOLED**：采用非数据库池的管理方式，每次请求都会新建一个连接，并且用完后会关闭，所以性能并不高\n		**POOLED**：采用连接池的概念将数据库链接对象Connection起来，可以在初始化的时候创建多个连接，使用时直接从连接池获取，避免重复创建连接的时间，效率较高\n		**JNDI**：数据源JNDI的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI的上下文引用，生产环境优先考虑\n - **property**：dataSource中的property元素就是数据库相关的配置信息\n - **mappers**：用来存放mapper的标签\n - **mapper**：映射文件资源位置，如下代码所示\n\n```xml\n<mappers>\n	<mapper resource=\"mapper/StudentMapper.xml\">\n</mappers>\n```\n\n## SQL映射文件\n\n - 命名空间用来设定当前配置文件的唯一标识，在Java程序中将通过namespace定位该配置文件，名字可以随便取，但是推荐用mapper的全类名\n - id：sql映射语句的唯一标识，称为statement的id，将sql语句封装到mappedStatement对象中，所以将id称为statement的id\n - parameterType: 指定输入参数类型\n - resultType: 指定输出结果类型。Mybatis将sql查询结果的一行记录映射为resultType指定对象，如果有多条则分别映射最后放入Lise容器\n - #{value}表示sql语句的占位符，相当于jdbc的？会自动进行jdbc类型和Java类型转换，不可以为空\n - ${value}表示拼接字符串，会导致sql注入\n\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!-- mapper标签是当前配置文件的根标签 -->\n<!-- namespace属性：表示命名空间，用来设定当前Mapper配置文件的唯一标识，将来在Java程序中通过namespace属性的值来定位到这个配置文件 -->\n<mapper namespace=\"com.th.entity.Student\">\n    <!-- 查询所有学生 -->\n    <select id=\"selectAllStudent\" resultType=\"com.th.entity.Student\">\n        select * from t_student;\n    </select>\n    <!-- 通过Id查询一个学生 -->\n    <select id=\"selectStudentById\" parameterType=\"int\" resultType=\"com.th.entity.Student\">\n        select * from t_student where id = #{id};\n    </select>\n    <!-- 模糊查询，根据name字段查询学生-->\n    <select id=\"selectStudentByName\" parameterType=\"int\" resultType=\"com.th.entity.Student\">\n        select * from t_student where s_name like \'%${value}%\';\n    </select>\n    <!-- 添加学生-->\n    <insert id=\"insertStudent\" parameterType=\"com.th.entity.Student\">\n        insert into t_student(s_name, age, sex)\n        values (#{s_name}, #{age}, #{sex});\n    </insert>\n    <!-- 根据Id更新学生 -->\n    <update id=\"updateStudent\" parameterType=\"com.th.entity.Student\">\n        update t_student set s_name = #{s_name},\n            age = #{age},sex = #{sex} where id = #{id};\n    </update>\n    <!-- 根据Id删除学生 -->\n    <delete id=\"deleteStudent\" parameterType=\"int\">\n        delete from t_student where id = #{id};\n    </delete>\n</mapper>\n\n\n```\n\n## 加载映射文件\n\n```xml\n\n    <!--指定映射配置文件的位置，这个映射配置文件指的是每个业务独立的配置文件-->\n    <mappers>\n        <mapper resource=\"mapper/StudentMapper.xml\"/>\n    </mappers>\n```\n\n\n## 日志与测试类\n```yml\n\n# Set root category priority to INFO and its only appender to CONSOLE.\n#log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal\nlog4j.rootCategory=debug, CONSOLE, LOGFILE\n\n# Set the enterprise logger category to FATAL and its only appender to CONSOLE.\nlog4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE\n\n# CONSOLE is set to be a ConsoleAppender using a PatternLayout.\nlog4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender\nlog4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n# LOGFILE is set to be a File appender using a PatternLayout.\nlog4j.appender.LOGFILE=org.apache.log4j.FileAppender\nlog4j.appender.LOGFILE.File=F:/axis.log\nlog4j.appender.LOGFILE.Append=true\nlog4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout\nlog4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\\n\n\n\n```\n\n```java\n\npackage com.th.test;\n\n/**\n * @author: lxk\n * @date: 2021/7/24 22:57\n * @description: Mybatis测试类\n * @modified By:\n */\n\nimport com.th.entity.Student;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.io.InputStream;\nimport java.util.List;\n\n/**\n * Mybatis的测试\n */\n\n/**\n * Mybatis的测试\n */\npublic class MybatisTest {\n    //定义 SqlSession\n    SqlSession sqlSession = null;\n\n    @Before\n    public void getSqlSession() {\n        //加载 mybatis 全局配置文件\n        InputStream is = MybatisTest.class.getClassLoader().getResourceAsStream(\"mybatis-config.xml\");\n        //创建 SqlSessionFactory 对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);\n        //根据 sqlSessionFactory 产生 session\n        sqlSession = sqlSessionFactory.openSession();\n    }\n\n    //查询所有用户数据\n    @Test\n    public void testSelectAllStudent() {\n        /**\n         * 注意：这个字符串由 UserMapper.xml 文件中的两个部分构成(namespace + id)\n         * <mapper namespace=\"com.thr.mapper.UserMapper\">中 namespace 的值\n         * <select id=\"selectAllUser\" > 中的 id 值\n         * 这样Mybatis才能找到需要的SQL\n         */\n        String statement = \"com.th.entity.Student.selectAllStudent\";\n        List<Student> listStudent = sqlSession.selectList(statement);\n        for (Student student : listStudent) {\n            System.out.println(student.toString());\n        }\n        sqlSession.close();\n    }\n\n    //根据Id查询一个用户数据\n    @Test\n    public void testSelectStudentById() {\n        String statement = \"com.th.entity.Student.selectStudentById\";\n        Student student = sqlSession.selectOne(statement, 1);\n        System.out.println(student.toString());\n        sqlSession.close();\n    }\n\n    //模糊查询：根据 user 表的username字段\n    @Test\n    public void testSelectStudentByName() {\n        String statement = \"com.th.entity.Student.selectStudentByName\";\n        List<Student> listStudent = sqlSession.selectList(statement, \"三\");\n        for (Student student : listStudent) {\n            System.out.println(student.toString());\n        }\n        sqlSession.close();\n    }\n\n    //添加一个用户数据\n    @Test\n    public void testInsertStudent() {\n        String statement = \"com.th.entity.Student.insertStudent\";\n        Student user = new Student();\n        user.setS_name(\"张三丰\");\n        user.setAge(34);\n        user.setSex(\"男\");\n        int i = sqlSession.insert(statement, user);\n        System.out.println( (i>0)? \"添加成功！\":\"添加失败！\");\n        //提交插入的数据\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    //根据Id修改用户数据\n    @Test\n    public void testUpdateStudent(){\n        //如果设置的 id不存在，那么数据库没有数据更改\n        String statement = \"com.th.entity.Student.updateStudent\";\n        Student user = new Student();\n        user.setId(3);\n        user.setS_name(\"王红\");\n        user.setAge(26);\n        user.setSex(\"女\");\n        int i = sqlSession.update(statement, user);\n        System.out.println( (i>0)? \"修改成功！\":\"修改失败！\");\n        //提交数据\n        sqlSession.commit();\n        sqlSession.close();\n    }\n\n    //根据Id删除用户数据\n    @Test\n    public void testDeleteStudent(){\n        String statement = \"com.th.entity.Student.deleteStudent\";\n        int i = sqlSession.delete(statement, 4);\n        System.out.println( (i>0)? \"删除成功！\":\"删除失败！\");\n        sqlSession.commit();\n        sqlSession.close();\n    }\n}\n\n\n\n```\n\n\n\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:18:58', '2023-01-25 11:42:51');
INSERT INTO `article` VALUES (62, 1, 'Mybatis学习笔记（三）', '# 全局配置文件\n配置文件内顺序不能改\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n \n<configuration> <!--配置-->\n    <properties/> <!--属性-->\n    <settings/> <!--全局配置参数-->\n    <typeAliases/> <!--类型别名-->\n    <typeHandlers/> <!--类型处理器-->\n    <objectFactory/><!--对象工厂-->\n    <plugins/><!--插件-->\n    <environments default=\"\"><!--环境配置-->\n        <environment id=\"\"><!--环境变量-->\n            <transactionManager type=\"\"/><!--事务管理器-->\n            <dataSource type=\"\"/><!--数据源-->\n        </environment>\n    </environments>\n    <databaseIdProvider type=\"\"/><!--数据库厂商标识-->\n    <mappers/><!--映射器-->\n</configuration>\n```\n\n# properties属性\n作用：引用Java属性文件中的配置信息\n\nmybatis提供三种方式配置properties属\n 1. property子元素 (影响配置文件整洁)\n```xml\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\n \n<configuration>\n    <properties>\n        <!--property子元素定义-->\n        <property name=\"database.driver\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"database.url\" value=\"jdbc:mysql://localhost:3306/user?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8\"/>\n        <property name=\"database.username\" value=\"root\"/>\n        <property name=\"database.password\" value=\"root\"/>\n    </properties>\n    <environments default=\"development\">\n        <environment id=\"development\">\n            <transactionManager type=\"JDBC\"></transactionManager>\n            <dataSource type=\"POOLED\">\n                <!--配置连接数据库的4个基本信息-->\n                <property name=\"driver\" value=\"${database.driver}\"/>\n                <property name=\"url\" value=\"${database.url}\"/>\n                <property name=\"username\" value=\"${database.username}\"/>\n                <property name=\"password\" value=\"${database.password}\"/>\n            </dataSource>\n        </environment>\n    </environments>\n</configuration>\n```\n 2. properties文件\n\n```xml\n创建一个叫database.properties的配置文件，写入如下代码\n#数据库连接配置\ndatabase.driver=com.mysql.cj.jdbc.Driver\ndatabase.url=jdbc:mysql://localhost:3306/user?serverTimezone=GMT%2B8&useUnicode=true&characterEncoding=utf-8\ndatabase.username=root\ndatabase.password=root\n然后在Mybatis配置文件中使用<properties>元素的resource属性来引入properties文件\n<properties resource=\"database.properties\" />\n\n```\n\n\n3. 程序代码传递参数\n\n```java\npublic static SqlSessionFactory getSqlSessionFactoryByXml() {\n        synchronized (Lock) {\n            if (null != sqlSessionFactory) {\n                return sqlSessionFactory;\n            }\n            String resource = \"mybatis-config.xml\";\n            InputStream inputStream;\n            InputStream is = null;\n            try {\n                // 加载数据库配置文件\n                is = Resources.getResourceAsStream(\"database.properties\");\n                Properties properties = new Properties();\n                properties.load(is);\n \n                // 获取加密信息\n                String username = properties.getProperty(\"database.username\");\n                String password = properties.getProperty(\"database.password\");\n \n                // 解密用户名和密码，并重置属性\n                properties.setProperty(\"database.username\", CyperTool.decodeByBase64(username));\n                properties.setProperty(\"database.password\", CyperTool.decodeByBase64(password));\n                // 读取mybatis配置文件\n                inputStream = Resources.getResourceAsStream(resource);\n                // 通过SqlSessionFactoryBuilder类的builder方法进行构建，并使用程序传递的方式覆盖原有属性\n                sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, properties);\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n            return sqlSessionFactory;\n        }\n    }\n\n```\n使用synchornized锁保证数据的准确性\n	代码逻辑：\n	\n首先使用 Resources获取database.properties配置文件，\n\n然后获取它原来配置的用户和密码进行解密操作，\n\n最后使用SqlSessionFactoryBuilder的build方法传递多个properties参数覆盖之前的加密配置\n\n# settings属性\n```xml\n<settings>\n    <!--缓存配置的全局开关：如果这里设置成false，那么即便在映射器中配置开启也无济于事 -->\n    <setting name=\"cacheEnabled\" value=\"true\" />\n    <!--延时加载的全局开关 -->\n    <setting name=\"lazyLoadingEnabled\" value=\"false\" />\n    <!-- 是否允许单一语句返回多结果集 -->\n    <setting name=\"multipleResultSetsEnabled\" value=\"true\" />\n    <!-- 使用列标签代替列名，需要兼容驱动 -->\n    <setting name=\"useColumnLabel\" value=\"true\" />\n    <!-- 允许JDBC自动生成主键，需要驱动兼容。如果设置为true，则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍能正常工作 -->\n    <setting name=\"useGeneratedKeys\" value=\"false\" />\n    <!-- 指定MyBatis该如何自动映射列到字段或属性：NONE表示取消自动映射；PARTIAL表示只会自动映射，没有定义嵌套结果集和映射结果集；\n    FULL会自动映射任意复杂的结果集，无论是否嵌套 -->\n    <setting name=\"autoMappingBehavior\" value=\"PARTIAL\" />\n    <!-- 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志FAILING: 映射失败 (抛出 SqlSessionException) -->\n    <setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\" />\n    <!-- 配置默认的执行器：SIMPLE是普通的执行器；REUSE会重用预处理语句；BATCH会重用语句并执行批量更新 -->\n    <setting name=\"defaultExecutorType\" value=\"SIMPLE\" />\n    <!--设置超时时间：它决定驱动等待数据库响应的秒数,任何正整数-->\n    <setting name=\"defaultStatementTimeout\" value=\"25\"/>\n    <!--设置数据库驱动程序默认返回的条数限制，此参数可以重新设置,任何正整数 -->\n    <setting name=\"defaultFetchSize\" value=\"100\" />\n    <!-- 允许在嵌套语句中使用分页（RowBounds） -->\n    <setting name=\"safeRowBoundsEnabled\" value=\"false\" />\n    <!-- 是否开启自动驼峰命名规则，即从a_example到aExample的映射 -->\n    <setting name=\"mapUnderscoreToCamelCase\" value=\"true\" />\n    <!-- 本地缓存机制，防止循环引用和加速重复嵌套循环 -->\n    <setting name=\"localCacheScope\" value=\"SESSION\" />\n    <!-- 当没有为参数提供特定JDBC类型时，为空值指定JDBC类型。某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，如NULL/VARCHAR/OTHER -->\n    <setting name=\"jdbcTypeForNull\" value=\"OTHER\" />\n    <!-- 指定触发延迟加载的方法，如equals/clone/hashCode/toString -->\n    <setting name=\"lazyLoadTriggerMethods\" value=\"equals\" />\n</settings>\n\n```\n\n# typeAlianses属性\ntypeAlianses属性就是起别名，是为了在映射文件中更方便的编写输入参数类型和输出结果类型\n系统定义的别名如：int、string等\n自定义别名的三种方法：\n```xml\n<!--配置别名-->\n1. 指定名字\n<typeAliases>\n    <!--对类单独进行别名设置  -->\n    <typeAlias alias=\"user\" type=\"com.thr.pojo.User\"></typeAlias>\n    <typeAlias alias=\"student\" type=\"com.thr.pojo.Student\"></typeAlias>\n</typeAliases>\n2. 自动生成\n<typeAliases>\n    <!-- 对包进行扫描，可以批量进行别名设置，设置规则是：获取类名称，将其第一个字母变为小写 -->\n    <package name=\"com.thr.pojo1\"/>\n    <package name=\"com.thr.pojo2\"/>\n    <package name=\"com.thr.pojo3\"/>\n</typeAliases>\n```\n```java\n\n3.通过注解\npackage com.thr.pojo1;\nimport org.apache.ibatis.type.Alias;\n \n@Alias(\"user1\")\npublic class User {\n    ...\n}\n\n```\n# typeHandlers属性：\n	 typeHandlers叫类型处理器（保留）\n	\n# objectFacotry属性：\n	objectFacotry表示为对象工厂（保留）\n	\n# plugins属性：\n	插件\n\n# environments属性：\nenvironments属性表示的是运行环境，主要的作用是配置数据库的一些信息，我们可以配置多个数据库，但只能选择一个。它里面分为两个可配置的元素：事务管理器(transactionManager)、数据源(DataSource)\n\n# databaseIdProvider属性\n	databaseIdProvider元素主要是为了支持不同厂商的数据库\n\n# mappers属性\n	mapper属性是用来加载映射文件的，也就是加载我们配置的SQL映射文件\nmapper有四种加载方法：\n\n```xml\n1.用文件路径引入\n<mappers>\n    <mapper resource=\"com/thr/mapper/UserMapper.xml\" />\n    <mapper resource=\"com/thr/mapper/StudentMapper.xml\" />\n    <mapper resource=\"com/thr/mapper/TeacherMapper.xml\" />\n</mappers>\n2.使用URL方式引入\n<mappers>\n    <mapper url=\"D:/mappers/UserMapper.xml\" />\n    <mapper url=\"D:/mappers/StudentMapper.xml\" />\n</mappers>\n3.用类注册引入\n<mappers>\n    <mapper class=\"com.thr.mapper.UserMapper\" />\n    <mapper class=\"com.thr.mapper.StudentMapper\" />\n    <mapper class=\"com.thr.mapper.TeacherMapper\" />\n</mappers>\n4.用包名引入（推荐）\n<mappers>\n    <package name=\"com.thr.mapper\"/>\n</mappers>\n```\n\n\n\n\n\n\n', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:45:03', '2023-01-25 11:45:03');
INSERT INTO `article` VALUES (63, 1, 'Mybatis学习笔记（四）', '# SQL映射文件（xxxMapper.xml）\nSQL映射文件是用来配置SQL映射语句的，根据不同类型的sql语句选择不同的标签，常用的顶级元素有：\n|元素|描述  |\n|--|--|\n| resultMap(重要)| 用于接收查询结果 |\n|sql|可重用语句块|\n|select|映射查找语句|\n|update|映射修改语句|\n|insert|映射插入语句|\n|delete|映射删除语句|\n\n# select主要元素\n|select内部属性|描述  |\n|--|--|\n|id  |  在命名空间中唯一的标识符，可以被用来引用这条语句|\n|  parameterType|  传入这条语句的参数类的完全限定名或别名|\n|resultType  |从这条语句中返回的期望类型的类的完全限定名或别名，如果是集合应该填写集合所包含的类型  |\n| resultMap | 自定义的 resultType |\n| flushCache | 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false |\n| useCache| 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true |\n\n# insert主要元素\n|insert内部属性| 描述 |\n|--|--|\n| id | 在命名空间中唯一的标识符，可以被用来引用这条语句 |\n| parameterType | 传入这条语句的参数类的完全限定名或别名 |\n| useGeneratedKeys | （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false |\n\n## 主键回填\n\n> 在insert元素中，有一个非常重要且常用的属性——**useGeneratedKeys**，它的作用的主键回填，就是将当前插入数据的主键返回。例如在插入语句中，我们没有插入主键 Id 列，因为在mysql数据库中将它设置为自增主键，数据库会自动为其生成对应的主键，所以没必要插入。但是有些时候我们还需要继续使用这个主键，用以关联其它业务，所以十分有必要获取它。比如在新增用户的时候，首先会插入用户的数据，然后插入用户和角色关系表，而插入用户时如果没办法取到用户的主键，那么就没有办法插入用户和角色关系表了，因此这个时候需要拿到对应的主键，以方便关联表的操作。\n\n使用案例留空\n\n# update和delete元素\n\n> 它们和insert元素的属性差不多，执行完后也会返回一个整数，用来表示该SQL语句影响了数据库的记录行数\n\n# sql元素\n\n> sql元素是用来定义可重用的 sql代码片段，这样在字段比较多的时候，以便在其它语句中使用。\n\n```xml\n<!--定义sql代码片段-->\n<sql id=\"userCols\">\n    id,username,age,sex,address\n</sql>\n```\n## sql元素还支持变量的传递\n```xml\n<!--定义sql代码片段-->\n<sql id=\"userCols\">\n    ${alias}.id,${alias}.username,${alias}.age,${alias}.sex,${alias}.address\n</sql>\n<!-- 查询所有用户 -->\n<select id=\"selectAllUser\" resultType=\"com.thr.entity.User\">\n    select <include refid=\"userCols\">\n              <property name=\"alias\" value=\"u\"/>\n           </include>\n    from t_user u\n</select>\n\n```\n# parameterType \n传入类型包括以下几类\n## 1.映射基本数据类型（即八大基本数据类型，比如int，boolean，long等类型）\n\n\n## 2.映射pojo类型(即普通的对象)\n\n## 3. 包装pojo类型(包装pojo类型在Mybatis使用（二）中有使用示例，即内部属性为对象引用，集合等)\n## 4.映射map类型 （还没用到）\n\n# resultType\n\n## 1.映射基本数据类型（即八大基本数据类型，比如int，boolean，long等类型）\n\n## 2.映射pojo类型(即普通的对象)\n\n## 3.映射pojo列表（映射多列数据）\n\n> 映射单个pojo对象和映射pojo列表映射文件中的resultType都配置为pojo类型。区别只是返回单个对象是内部调用selectOne返回pojo对象，返回pojo列表时内部调用selectList方法\n\n```xml\n<!-- 查询所有用户 -->\n<select id=\"selectAllUser\" resultType=\"com.thr.entity.User\">\n    select * from t_user\n</select>\n\n```\n## 4.映射hashmap\n\n# resultMap', NULL, '10,11', '', 1, 0, 0, '2023-01-25 11:45:33', '2023-01-25 11:45:33');
INSERT INTO `article` VALUES (64, 1, 'Centos7安装nginx-1.9.9', '# 安装环境\n\n记录安装nginx流程，使用系统centos7\n\n## 安装所需插件\n### 1.安装gcc\ngcc是linux下的编译器\n查看gcc版本\n\n```\ngcc -v\n```\n![gcc版本信息](https://img-blog.csdnimg.cn/20210717165407722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzEwMjE5,size_16,color_FFFFFF,t_70)\n我的阿里云centos7系统自带gc，如果没有可以使用以下命令下载gcc\n\n```\nyum -y install gcc\n```\n### 2.安装pcre、pcre-devel\nPCRE (Perl Compatible Regular Expressions) 是一个用C语言编写的正则表达式函数库。\n安装命令如下：\n\n```\nyum install -y pcre pcre-devel\n```\n### 3.安装zlib\nzlib是一个压缩库，类似于zip。在linux下看到的*.gz文件，就是用zlib压缩的。\n安装命令：\n\n```\nyum install -y zlib zlib-devel\n```\n### 4.安装openssl\nOpenSSL是一个开放源代码的软件库包，应用程序可以使用这个包来进行安全通信，避免窃听，同时确认另一端连接者的身份。\n安装命令：\n\n```\nyum install -y openssl openssl-devel\n```\n## 安装nginx\n我安装的nginx是1.9.9版本的，首先在 /usr/local 路径下面创建nginx文件夹，然后 cd进入该文件夹开始下载nginx安装包\n安装命令：\n\n```\nwget http://nginx.org/download/nginx-1.9.9.tar.gz  \n```\n### 安装完成之后解压到 /usr/local/nginx路径下面\n解压命令\n\n```\ntar -zxvf  nginx-1.9.9.tar.gz\n```\n### 然后进入 /usr/local/nginx/nginx-1.9.9/下\n运行三个命令：\n\n```\n./configure\n \nmake\n \nmake install\n```\n### 之后再进入 /usr/local/nginx/conf/ 目录下面修改nginx的配置文件，主要是修改nginx.conf文件中的端口号信息\n![端口号](https://img-blog.csdnimg.cn/20210717172821625.png)\n将端口号修改为80，不过默认都是80端口，如果需要修改则 按 i 键进入修改，修改完成之后先按 esc 然后 shirf + zz 退出保存。\n\n## 最后就是启动nginx\n进入/usr/local/nginx/sbin 目录下面\n执行：`./nginx` 即可启动nginx，到此为止nginx已经安装完成了\n输入你的ip地址即可访问\n\n如果访问不成功那可能是防火墙的问题\n\n## 启动失败\n执行` ./nginx `提示\nnginx: [alert] could not open error log file: open() \"/usr/local/nginx/logs/error.log\" failed (2: No such file or directory)\n2021/09/16 14:15:15 [emerg] 18033#0: open() \"/usr/local/nginx/logs/access.log\" failed (2: No such file or directory)\n需要在nginx目录下创建logs文件夹\n```\nmkdir logs\nchmod 755 logs\n```\n\n## 解决防火墙问题\n首先要简单确认80端口有没有分给nginx\n执行命令：`netstat -ntlp`\n![80端口](https://img-blog.csdnimg.cn/2021071717374941.png)\n### 第一步\n对防火墙进行配置\n\n```\nfirewall-cmd --zone=public --add-port=80/tcp --permanent\n```\n如果执行第一步提示\n\n![防火墙](https://img-blog.csdnimg.cn/20210717174020153.png)\n则是防火墙未开启\n可以通过systemctl status firewalld确认firewalld状态。dead状态即为防火墙未开启\n\n#### 然后执行systemctl start firewalld开启防火墙，没有提示信息即为防火墙开启成功\n再次执行systemctl status firewalld确认firewalld状态。出现绿色的running则是防火墙开启成功\n接下来就再次执行`firewall-cmd --zone=public --add-port=80/tcp --permanent`开启防火墙\n### 第二布\n重启防火墙就可以了\n\n```\nsystemctl restart firewalld.service\n```\n\n', NULL, '8,9', '', 1, 0, 0, '2023-01-25 11:46:29', '2023-01-25 11:47:57');
INSERT INTO `article` VALUES (65, 1, 'ActiveMQ学习笔记（一）：安装与目录介绍', '# 安装\r\n\r\n![安装地址](http://121.4.126.60/file/img/article/activemq-1.png)\r\n\r\n\r\n\r\n# 目录说明\r\n```\r\nbin----存放的是脚本文件\r\nconf----存放的是基本配置文件\r\ndata----存放的是日志文件\r\ndocs----存放的是说明文档\r\nexamples----存放的是简单的实例\r\nlib----存放的是activemq所需jar包\r\nwebapps----用于存放项目的目录\r\n```\r\n\r\n\r\n\r\n\r\n# 启动\r\n![启动](http://121.4.126.60/file/img/article/activemq-2.png)\r\n以管理员权限启动activemq.bat文件,注意cmd窗口关闭之后127.0.0.1:8161将无法访问到\r\n\r\n如果想要关闭cmd窗口访问activemq管理页面可以 打开计算机管理，启动activemq服务\r\n启动步骤：\r\nwindows + x 打开计算机管理\r\n![启动服务](http://121.4.126.60/file/img/article/activemq-3.png)\r\n\r\n\r\n# 控制台简介\r\n```\r\nQueues：队列方式消息。\r\nTopics：主题方式消息。\r\nSubscribers：消息订阅监控查询。\r\nConnections：查看链接数,分别可以查看xmpp、ssl、stomp、openwire、ws和网络链接。\r\nNetwork：网络链接数监控。\r\nScheduled：不太清楚。\r\nSend：发送消息数据\r\n```\r\n\r\n\r\n\r\n\r\n\r\n# 配置文件简介\r\n\r\n## 登录管理\r\n登陆管理配置文件在 conf/jetty.xml 文件中\r\n![登录配置文件](http://121.4.126.60/file/img/article/activemq-4.png)\r\nroles表示有管理员和用户的角色\r\nauthenticate表示权限，value为true时需要用户登录\r\n\r\n用户登录配置文件在 conf/jetty-realm.properties 文件中\r\n![用户登录](http://121.4.126.60/file/img/article/activemq-5.png)\r\n格式为： 账号， 密码\r\n\r\n## 端口号管理\r\n端口号管理文件 conf/jetty.xml 目录中\r\n![端口号管理文件](http://121.4.126.60/file/img/article/activemq-6.png)\r\n8161即为activemq的端口号\r\n\r\n## ActiveMQ连接服务端的方式\r\n配置文件在 conf/activemq.xml 中\r\n![连接服务端](http://121.4.126.60/file/img/article/activemq-7.png)\r\n\r\n## 持久化配置\r\n持久化默认方式为 kahaDB ，文件在 conf/activemq.xml 中\r\n![持久化](http://121.4.126.60/file/img/article/activemq-8.png)\r\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:18:22', '2023-01-26 14:56:13');
INSERT INTO `article` VALUES (66, 1, 'ActiveMQ学习笔记（二）：点对点方式学习', '# 介绍\r\n点对点的消息发送方式主要建立在消息（Message），队列（Queue），发送者（Sender），消费者（Receiver）上，Queue存储消息，Sender发送消息，Receiver接收消息，具体流程是Sender Client通过Queue发送message，Receiver Client从Queue中接收消息。消息的发送客户端和消息接收客户端没有时间上的依赖，可以异步进行\r\n\r\n# 通过jms编码接口之间的关系\r\n1. ConnectionFactory创建连接Connection\r\n2. Connection创建会话Session\r\n3. 通过Session创建其它的（MessageProducer、MessageConsumer、Destination、TextMessage）\r\n4. 将生产者和消费者指向Destination\r\n5. 生产者向目标发送TextMessage消息send()\r\n6. 消费者设置监听器，监听消息\r\n![jms](http://121.4.126.60/file/img/article/activemq2-1.png)\r\n\r\n\r\n# 创建项目\r\n新建maven项目\r\n![maven](http://121.4.126.60/file/img/article/activemq2-2.png)\r\n创建文件目录，先删除之前的src目录\r\n![src](http://121.4.126.60/file/img/article/activemq2-3.png)\r\n创建完成\r\n![dir](http://121.4.126.60/file/img/article/activemq2-4.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n# 创建生产者\r\n```\r\npackage org.emample.jms;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\nimport javax.jms.*;\r\n\r\n/**\r\n * @author: lxk\r\n * @date: 2021/8/1 10:03\r\n * @description: 生产者\r\n * @modified By:\r\n */\r\npublic class producer {\r\n    // ActiveMQ的服务器tcp连接方式\r\n    private static final String url = \"tcp://127.0.0.1:61616\";\r\n    // 定义队列的名称\r\n    private static final String queueName = \"queue-test\";\r\n\r\n    public static void main(String[] args) throws JMSException {\r\n        // 1.创建connectionFactory\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\r\n        // 2.创建connection\r\n        Connection connection = connectionFactory.createConnection();\r\n        // 3.启动连接\r\n        connection.start();\r\n        // 4.创建session\r\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r\n        // 5.创建destination\r\n        Destination destination = session.createQueue(queueName);\r\n        // 6.创建生产者\r\n        MessageProducer producer = session.createProducer(destination);\r\n\r\n        for (int i=0; i<100; i++){\r\n            TextMessage textMessage = session.createTextMessage(\"发送文本\" + i);\r\n            producer.send(textMessage);\r\n            if ((i+1)%10 == 0) {\r\n                System.out.println(\"已发送\" + (i+1)/10 + \"组\");\r\n            }\r\n        }\r\n        // 7.关闭连接\r\n        connection.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n# 创建消费者\r\n```\r\npackage org.emample.jms;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\nimport javax.jms.*;\r\n\r\n/**\r\n * @author: lxk\r\n * @date: 2021/8/1 10:05\r\n * @description: 消费者\r\n * @modified By:\r\n */\r\npublic class consumer {\r\n\r\n    // ActiveMQ的服务器tcp连接方式\r\n    private static final String url = \"tcp://127.0.0.1:61616\";\r\n    // 定义队列的名称\r\n    private static final String queueName = \"queue-test\";\r\n\r\n    public static void main(String[] args) throws JMSException {\r\n        // 1.创建connectionFactory\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\r\n        // 2.创建connection\r\n        Connection connection = connectionFactory.createConnection();\r\n        // 3.启动连接\r\n        connection.start();\r\n        // 4.创建session\r\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r\n        // 5.创建destination\r\n        Destination destination = session.createQueue(queueName);\r\n        // 6.创建消费者\r\n        MessageConsumer consumer = session.createConsumer(destination);\r\n        // 7.创建监听器\r\n        consumer.setMessageListener(new MessageListener() {\r\n            @Override\r\n            public void onMessage(Message message) {\r\n\r\n                TextMessage textMessage = (TextMessage) message;\r\n                try {\r\n                    System.out.println(\"收到消息\" + textMessage.getText());\r\n                } catch (JMSException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n\r\n        // 8.关闭连接(监听器是异步的还没有监听到消息的时候，就关闭连接了)\r\n        // connection.close();\r\n    }\r\n}\r\n```\r\n# 启动\r\n注： 启动时会有一个slf4j的报错信息\r\n![error](http://121.4.126.60/file/img/article/activemq2-5.png)\r\n在pom文件中添加下图内容就可以解决，具体原因参考大佬的文章：https://blog.csdn.net/weixin_39548940/article/details/100015174\r\n```\r\n    <dependency>\r\n      <groupId>org.slf4j</groupId>\r\n      <artifactId>slf4j-nop</artifactId>\r\n      <version>1.7.2</version>\r\n    </dependency>\r\n```\r\n生产者发送信息\r\n![producer](http://121.4.126.60/file/img/article/activemq2-6.png)\r\n然后启动消费者\r\n![consumer](http://121.4.126.60/file/img/article/activemq2-7.png)\r\n\r\n## 测试两个消费者\r\n### 启动方式：\r\n1. 选择消费者\r\n2. 点击 Edit Configurations...\r\n![点击](http://121.4.126.60/file/img/article/activemq2-8.png)\r\n3.勾选 Allow parallel run 按钮\r\n![勾选](http://121.4.126.60/file/img/article/activemq2-9.png)\r\n\r\n### 测试\r\n先启动两个消费者\r\n![consumer](http://121.4.126.60/file/img/article/activemq2-10.png)\r\n然后启动生产者\r\n![producer](http://121.4.126.60/file/img/article/activemq2-11.png)\r\n观察消费者消息接收情况\r\n![consumer1](http://121.4.126.60/file/img/article/activemq2-12.png)\r\n![consumer2](http://121.4.126.60/file/img/article/activemq2-13.png)\r\n可以看到两个消费者收到的消息并不重复\r\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:18:47', '2023-01-26 14:56:02');
INSERT INTO `article` VALUES (67, 1, 'ActiveMQ学习笔记（三）：发布订阅模式', '# 发布订阅模式\r\n发布订阅模式与点对点模式主要区别为，点对点模式支持异步，并且只能有一个接收者，而发布订阅模式可以有很多订阅者，但是不支持异步\r\n\r\n\r\n# 代码实现\r\n## 发布者\r\n```\r\npackage org.emample.jms;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\nimport javax.jms.*;\r\n\r\n/**\r\n * @author: lxk\r\n * @date: 2021/8/1 10:23\r\n * @description: 发布订阅模式生产者\r\n * @modified By:\r\n */\r\npublic class producerTopic {\r\n    // ActiveMQ的服务器tcp连接方式\r\n    private static final String url = \"tcp://127.0.0.1:61616\";\r\n    // 定义主题的名称\r\n    private static final String topicName = \"topic-test\";\r\n\r\n    public static void main(String[] args) throws JMSException {\r\n        // 1.创建connectionFactory\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\r\n        // 2.创建connection\r\n        Connection connection = connectionFactory.createConnection();\r\n        // 3.启动连接\r\n        connection.start();\r\n        // 4.创建session\r\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r\n        // 5.创建destination\r\n        Destination destination = session.createTopic(topicName);\r\n        // 6.创建生产者\r\n        MessageProducer producer = session.createProducer(destination);\r\n\r\n        for (int i=0; i<100; i++){\r\n            TextMessage textMessage = session.createTextMessage(\"发送文本\" + i);\r\n            producer.send(textMessage);\r\n            if ((i+1)%10 == 0) {\r\n                System.out.println(\"已发送\" + (i+1)/10 + \"组\");\r\n            }\r\n        }\r\n\r\n        connection.close();\r\n    }\r\n}\r\n\r\n```\r\n\r\n## 订阅者\r\n```\r\npackage org.emample.jms;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\nimport javax.jms.*;\r\n\r\n/**\r\n * @author: lxk\r\n * @date: 2021/8/1 10:23\r\n * @description: 发布订阅模式消费者\r\n * @modified By:\r\n */\r\npublic class consumerTopic {\r\n    public static final String url = \"tcp://127.0.0.1:61616\";\r\n    public static final String topicName = \"topic-test\";\r\n\r\n    public static void main(String[] args) throws JMSException {\r\n\r\n        // 1.创建connectionFactory\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\r\n        // 2.创建connection\r\n        Connection connection = connectionFactory.createConnection();\r\n        // 3.启动连接\r\n        connection.start();\r\n        // 4.创建session\r\n        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\r\n        // 5.创建destination\r\n        Destination destination = session.createTopic(topicName);\r\n        // 6.创建消费者\r\n        MessageConsumer consumer = session.createConsumer(destination);\r\n        // 7.创建监听器\r\n        consumer.setMessageListener(new MessageListener() {\r\n            @Override\r\n            public void onMessage(Message message) {\r\n\r\n                TextMessage textMessage = (TextMessage) message;\r\n                try {\r\n                    System.out.println(\"收到消息\" + textMessage.getText());\r\n                } catch (JMSException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n\r\n        // 8.关闭连接(监听器是异步的还没有监听到消息的时候，就关闭连接了)\r\n        // connection.close();\r\n\r\n    }\r\n}\r\n\r\n```\r\n# 启动测试\r\n先启动两个订阅者\r\n![consumer](http://121.4.126.60/file/img/article/activemq3-1.png)\r\n然后启动发布者\r\n![consumer1](http://121.4.126.60/file/img/article/activemq3-2.png)\r\n![consumer2](http://121.4.126.60/file/img/article/activemq3-3.png)\r\n可以看到两个订阅者收到了相同的内容\r\n', NULL, '15,16', '', 1, 0, 0, '2023-01-26 14:19:03', '2023-01-26 14:55:47');

-- ----------------------------
-- Table structure for article_label
-- ----------------------------
DROP TABLE IF EXISTS `article_label`;
CREATE TABLE `article_label`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL,
  `label_type` int(10) UNSIGNED NULL DEFAULT NULL COMMENT '标签类型id',
  `label_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  `article_num` tinyint(4) NULL DEFAULT NULL COMMENT '文章数量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_label
-- ----------------------------
INSERT INTO `article_label` VALUES (1, 1, 1, '算法', 2);
INSERT INTO `article_label` VALUES (2, 1, 1, '多线程', 2);
INSERT INTO `article_label` VALUES (3, 1, 1, 'mybatis', 1);
INSERT INTO `article_label` VALUES (4, 1, 2, 'dfs', 1);

-- ----------------------------
-- Table structure for article_label_type
-- ----------------------------
DROP TABLE IF EXISTS `article_label_type`;
CREATE TABLE `article_label_type`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL,
  `type_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标签分类名称',
  `label_num` tinyint(4) NULL DEFAULT NULL COMMENT '标签数量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_label_type
-- ----------------------------
INSERT INTO `article_label_type` VALUES (1, 1, 'java', 3);
INSERT INTO `article_label_type` VALUES (2, 1, '算法', 1);
INSERT INTO `article_label_type` VALUES (3, 1, '888', 0);

-- ----------------------------
-- Table structure for article_type
-- ----------------------------
DROP TABLE IF EXISTS `article_type`;
CREATE TABLE `article_type`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `parent_id` int(11) UNSIGNED NULL DEFAULT NULL COMMENT '文章分类上级 根分级为0',
  `type_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类名称',
  `num` int(11) NULL DEFAULT NULL COMMENT '文章数量',
  `node` tinyint(2) NULL DEFAULT NULL COMMENT '是否有子节点 （0：无 1：有）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 18 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_type
-- ----------------------------
INSERT INTO `article_type` VALUES (1, 0, '算法', 2, 1);
INSERT INTO `article_type` VALUES (2, 1, '洛谷', 2, 1);
INSERT INTO `article_type` VALUES (3, 2, '排序', 1, 1);
INSERT INTO `article_type` VALUES (4, 2, '搜索', 0, 0);
INSERT INTO `article_type` VALUES (5, 0, 'MySQL', 0, 1);
INSERT INTO `article_type` VALUES (6, 0, 'Spring', 0, 1);
INSERT INTO `article_type` VALUES (7, 6, '注解', 0, 1);
INSERT INTO `article_type` VALUES (8, 0, '安装教程', 0, 1);
INSERT INTO `article_type` VALUES (9, 8, 'Centos', 0, 1);
INSERT INTO `article_type` VALUES (10, 0, 'Mybatis', 0, 1);
INSERT INTO `article_type` VALUES (11, 10, '学习', 0, 1);
INSERT INTO `article_type` VALUES (12, 10, '使用', 0, 1);
INSERT INTO `article_type` VALUES (13, 0, 'JAVA', 0, 1);
INSERT INTO `article_type` VALUES (14, 13, 'JVM', 0, 1);
INSERT INTO `article_type` VALUES (15, 0, 'ActiveMQ', 0, 0);
INSERT INTO `article_type` VALUES (16, 15, '学习', 0, 1);
INSERT INTO `article_type` VALUES (17, 15, '使用', 0, 1);

-- ----------------------------
-- Table structure for blog_diary
-- ----------------------------
DROP TABLE IF EXISTS `blog_diary`;
CREATE TABLE `blog_diary`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(10) NULL DEFAULT NULL COMMENT '创建用户',
  `diary_md` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '日记md格式',
  `diary_date` date NULL DEFAULT NULL COMMENT '日记日期',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '最近更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 45 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of blog_diary
-- ----------------------------
INSERT INTO `blog_diary` VALUES (42, 1, '这个是7-14', '2022-07-14', '2022-07-14 17:12:29', '2022-07-14 17:16:31');
INSERT INTO `blog_diary` VALUES (43, 1, '11-04日期', '2022-11-04', '2022-07-15 09:13:39', '2022-07-15 09:13:39');
INSERT INTO `blog_diary` VALUES (44, 1, '11-05日期', '2022-11-05', '2022-08-04 14:07:37', '2022-08-04 14:07:40');

-- ----------------------------
-- Table structure for doc_catalog
-- ----------------------------
DROP TABLE IF EXISTS `doc_catalog`;
CREATE TABLE `doc_catalog`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建者id',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '父目录id',
  `doc_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文档名字',
  `doc_type` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文档类型（catalog：目录页 content：内容页）',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 37 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of doc_catalog
-- ----------------------------
INSERT INTO `doc_catalog` VALUES (24, 1, 0, '25365', 'catalog', '2023-01-23 09:47:04', '2023-01-23 09:47:24');
INSERT INTO `doc_catalog` VALUES (25, 1, 0, '787', 'content', '2023-01-23 09:47:09', '2023-01-23 09:47:22');
INSERT INTO `doc_catalog` VALUES (26, 1, 24, '25365', 'content', '2023-01-23 09:47:12', '2023-01-23 09:47:20');
INSERT INTO `doc_catalog` VALUES (30, 1, 26, '26262626', 'content', '2023-01-23 09:47:15', '2023-01-23 09:47:17');
INSERT INTO `doc_catalog` VALUES (31, 1, 24, '1231', 'catalog', '2023-01-23 10:02:11', '2023-01-23 10:02:11');
INSERT INTO `doc_catalog` VALUES (32, 1, 24, '111', 'catalog', '2023-01-23 10:03:40', '2023-01-23 10:03:40');
INSERT INTO `doc_catalog` VALUES (33, 1, 32, '222', 'catalog', '2023-01-23 10:03:58', '2023-01-23 10:03:58');
INSERT INTO `doc_catalog` VALUES (34, 1, 33, '123123123123', 'content', '2023-01-23 10:05:00', '2023-01-23 10:05:00');
INSERT INTO `doc_catalog` VALUES (35, 1, 33, '22', 'catalog', '2023-01-23 10:07:10', '2023-01-23 10:07:10');
INSERT INTO `doc_catalog` VALUES (36, 1, 35, '1', 'content', '2023-01-23 10:08:17', '2023-01-23 10:08:17');

-- ----------------------------
-- Table structure for doc_content
-- ----------------------------
DROP TABLE IF EXISTS `doc_content`;
CREATE TABLE `doc_content`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建者id',
  `catalog_id` int(11) NULL DEFAULT NULL COMMENT '目录id',
  `doc_content_md` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT 'md格式文档',
  `browse_count` int(11) NULL DEFAULT NULL COMMENT '文档浏览次数',
  `like_count` int(11) NULL DEFAULT NULL COMMENT '文档点赞次数',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '文档创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '文档最近修改时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of doc_content
-- ----------------------------
INSERT INTO `doc_content` VALUES (6, 1, 26, NULL, 0, 0, '2022-06-22 13:36:17', '2022-06-22 13:36:17');
INSERT INTO `doc_content` VALUES (7, 1, 25, NULL, 0, 0, '2022-06-22 13:37:42', '2022-06-22 13:37:42');
INSERT INTO `doc_content` VALUES (11, 1, 30, '232', 0, 0, '2022-06-22 15:43:52', '2022-06-22 15:43:52');
INSERT INTO `doc_content` VALUES (12, 1, 34, NULL, 0, 0, '2023-01-23 10:05:00', '2023-01-23 10:05:00');
INSERT INTO `doc_content` VALUES (13, 1, 36, NULL, 0, 0, '2023-01-23 10:08:17', '2023-01-23 10:08:17');

SET FOREIGN_KEY_CHECKS = 1;
